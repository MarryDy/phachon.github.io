<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Go 启动过程</title>
      <link href="/2018/09/09/go_bootstrap/"/>
      <url>/2018/09/09/go_bootstrap/</url>
      <content type="html"><![CDATA[<hr><p>通过查阅资料，了解 Go 语言的启动过程。</p><h2 id="启动总体顺序"><a href="#启动总体顺序" class="headerlink" title="启动总体顺序"></a>启动总体顺序</h2><ol><li>命令行参数解析</li><li>操作系统相关初始化</li><li>调度器初始化</li><li>创建 main.goroutine</li><li>运行 main 函数</li></ol><h3 id="命令行参数初始化"><a href="#命令行参数初始化" class="headerlink" title="命令行参数初始化"></a>命令行参数初始化</h3><p>主要是解析命令行参数并保存</p><h3 id="操作系统相关初始化"><a href="#操作系统相关初始化" class="headerlink" title="操作系统相关初始化"></a>操作系统相关初始化</h3><p>主要是确定操作系统的 CPU 核数，CPU 核数决定默认的了 P 的数量</p><a id="more"></a><h3 id="调度器初始化"><a href="#调度器初始化" class="headerlink" title="调度器初始化"></a>调度器初始化</h3><p>调度器的初始化时启动程序的核心</p><ol><li>设置 M 的最大数量（10000）</li><li>内存相关初始化</li><li>M 的初始化</li><li>存储命令行参数和环境变量</li><li>解析 Debug 调试参数</li><li>初始化垃圾回收器</li><li>初始化 poll 时间</li><li>社会最大的 P 的数量，默认是 CPU 核数</li></ol><h3 id="main-goroutine-初始化"><a href="#main-goroutine-初始化" class="headerlink" title="main.goroutine 初始化"></a>main.goroutine 初始化</h3><ol><li>设置栈的最大值</li><li>启动后台监控</li><li>初始化 runtime.init 及 runtime 包</li><li>启动垃圾回收器</li><li>初始化 main.init 及用户或第三方引入的包</li></ol><h3 id="执行-main-main-函数"><a href="#执行-main-main-函数" class="headerlink" title="执行 main.main 函数"></a>执行 main.main 函数</h3><p>执行入口函数，开始运行</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go 语言的并发机制</title>
      <link href="/2018/09/03/go_concurrent/"/>
      <url>/2018/09/03/go_concurrent/</url>
      <content type="html"><![CDATA[<hr><p>在操作系统的搭建的内核线程之上，go 语言搭建了一个特有的两极线程模型。首先来了解一下线程实现模型，然后再详细了解 go 语言实现的</p><h2 id="线程实现模型"><a href="#线程实现模型" class="headerlink" title="线程实现模型"></a>线程实现模型</h2><p>线程的实现模型主要有三种：用户级线程模型、内核级线程模型、两极线程模型。它们之间的区别主要是线程与内核调度对象之间的的对应关系。内核调度象也就是内核线程。</p><h3 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h3><p>用户级线程模型是由用户级别的线程库来全权管理的。也就是说，用户级线程模型下的线程是往往是通过应用程序的线程库来创建、切换、销毁的。与操作系统内核的线程没有关系。操作系统内核的线程调度器也无法<br>调度用户级线程模型创建的线程。内核线程调度器只能调度创建此线程的的应用程序的进程。一个进程对应多个用户级线程，所以这种线程模型又称为多对一（M:1）的线程模型, 如下图所示：<br><a id="more"></a><br><img src="/images/usp.png" alt="usp"></p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>对线程的各种管理调度与内核无关。应用程序对线程的创建、终止、切换等操作不需要让CPU从用户态切换到内核态。速度方面比较有优势</li><li>由于不依赖内核，所以程序的一致性比较强</li></ol><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol><li>由于此模型下内核调度的最小单位是进程。如果线程阻塞，则整个进程被阻塞。</li><li>不能真正利用多核 CPU 来实现并发。进程中的多个线程无法被分配到多个 CPU 中去执行。</li></ol><p>综上所述，由于缺陷明显，所以现在的操作系统一般不使用此种模型来实现线程</p><h3 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h3><p>和用户级线程相反，内核级线程是由内核来管理的，属于内核的一部分。应用程序对线程的创建、终止、切换等操作必须通过内核提供的系统调用来完成。进程中的每一个线程都与内核线程一一对应<br>由此，也称为一对一（1：1）的线程模型。如下图所示：</p><p><img src="/images/ssp.png" alt="ssp"></p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ol><li>一对一的线程模型消除了多对一的线程模型的不能真正并发的弊端，线程的管理由内核管理和调度，内核可以在不同的时间片内让CPU运行不同的线程。</li><li>即使某一个线程收到阻塞，其他线程不受影响</li></ol><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><ol><li>创建线程和管理线程的成本加大，要经常去系统调用来管理线程，线程管理的时间耗费的时间相对比较大。</li><li>如果一个进程包含大量的线程，将会给内核的调度器带来非常大的负担，甚至会影响操作系统的整体性能。</li><li>消耗更多的内核资源</li></ol><p>尽管内核级线程也有劣势，但是相比用户级线程的优势还是比较明显的。很多的现代的操作系统都是以内核级线程模型来实现线程的。包括 Linux 操作系统。<br>需要注意的是，在使用内核级线程模型时，必须了解每个进程允许的线程的最大数目是多少。防止线程数过大造成操作系统性能下降甚至崩溃。</p><h3 id="两极线程模型"><a href="#两极线程模型" class="headerlink" title="两极线程模型"></a>两极线程模型</h3><p>两极线程模型是根据用户级线程模型和内核级线程模型综合演变而来。可以说是取前两种模型之精华，去前两种模型之糟粕。在此模型下，一个进程可以与多个内核线程相关联。这与内核级线程相似。但与内核线程模型<br>不同的是，进程中的线程并不与内核线程一一对应，这些应用程序线程可以映射到同一个已关联的内核线程上。  </p><p>首先实现了两极线程模型的线程库会通过操作系统调用创建多个内核线程。然后，它会通过这些内核线程对应用程序线程进行调度。大多数的此类线程库都可以将这些应用程序线程动态的与内核线程相关联。在这种实现中，进程有着自己的内核线程池。可运行的用户线程由运行时库分派并标记为准备好执行的可用线程。<br>操作系统选择用户线程并将它映射到线程池中的可用内核线程。多个用户线程可以分配给相同的内核线程。<br>如下图所示：</p><p><img src="/images/csp.png" alt="ssp"></p><h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><ol><li>内核资源的消耗大大减少</li><li>线程管理操作的效率提高</li></ol><h4 id="劣势-2"><a href="#劣势-2" class="headerlink" title="劣势"></a>劣势</h4><ol><li>由于此种模型的线程设计使得管理工作变得更加复杂</li></ol><p>因为两极线程的复杂性，往往不会被操作系统所采用，但是，这样的模型却可以很好地在编程语言层面上实现并充分发挥作用。Go 语言的并发模型正是在该模型的基础上实现的。</p><h2 id="Go-语言并发模型"><a href="#Go-语言并发模型" class="headerlink" title="Go 语言并发模型"></a>Go 语言并发模型</h2><p>Go 的线程实现模型。有三个必知的核心元素。他们支撑起了模型的主要框架。</p><ul><li>M （machine）一个 M 代表一个内核线程</li><li>P （processor）一个 P 代表一个 Go 代码片段所必须的资源。goroutine依赖于 P 进行调度，P 是真正的并行单元；</li><li>G （goroutine）一个 G 代表一个 Go 代码片段。</li></ul><p>简单来说，一个 G 的执行，需要 P 和 M 的支持。一个 M 在一个 P 关联之后就形成了一个有效的 G 的运行环境（内核线程 + 上下文环境）。</p><p><img src="/images/go_sp.png" alt="go并发模型"></p><p>对应关系：  </p><ul><li>M 与操作系统内核线程是一对一的关系。即一个 M 只能代表一个内核级线程。并且他们之间的关系一旦关联一般不可改变。</li><li>M 与 P 之间的关系也是一对一的关系。但是他们之间的关联是易变的。会根据实际的调度来确定哪个 P 和 M 关联。</li><li>P 与 G 之间的关系是一对多的关系。因为每个 P 中都有一个可运行的 G 队列。</li></ul><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>上面已经讲了，一个 M 代表一个内核线程。一般情况下，创建 M 的时机一般是由于没有足够的 M 来管理 P ，并运行 P 中的可执行队列中的 G 。除此之外，在运行时系统执行监控和垃圾回收的过程中<br>也会导致新的 M 的创建。</p><h4 id="M-的核心结构字段"><a href="#M-的核心结构字段" class="headerlink" title="M 的核心结构字段"></a>M 的核心结构字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type M struct &#123;</span><br><span class="line">    g0          *g       // 特殊的 goroutine, 系统启动时创建，执行一些运行时任务</span><br><span class="line">    msstartfn   func()   // M 的其实函数。其实就是编写 go 语句时携带的函数</span><br><span class="line">    curg        *g       // 当前 M 正在执行的 G 指针</span><br><span class="line">    p           punittr  // 当前 M 关联的 P</span><br><span class="line">    nextp       punittr  // 当前 M 预关联的 P ，可以理解为提前关联</span><br><span class="line">    spinning    bool     // 当前 M 是否正在寻找可运行的 G</span><br><span class="line">    lockedg     *g       // 运行时系统可以把一个 M 和 一个 G 锁定在一起。那么这个 G 只能由这个 M 运行。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="M-的生命周期"><a href="#M-的生命周期" class="headerlink" title="M 的生命周期"></a>M 的生命周期</h4><ol><li>创建 M，M 在创建后加入全局的 M 列表中。起始函数和预关联的 P 都会被设置好。</li><li>运行时系统会为 M 专门创建一个新的内核线程并与之相关联。</li><li>初始化 M （栈空间，信号等）</li><li>开始执行起始函数（如果存在的话）</li><li>起始函数执行完成后，当前 M 会与预关联的 P 完成关联，并准备执行其他任务。M 会依次在多处寻找可运行的 G 。</li></ol><p>单个 Go 程序的 M 的最大值是可以设置的，初始化调度器的时候，会对 M 最大数量初始化。最大值为 10000。也就是说最多有 10000 个内核级线程服务于当前的 Go。但是在真正的操作系统运行环境中，基本上很难达到如此的量级的线程共存。<br>所以可以忽略 Go 本身对于线程数量的限制。也可以通过标准库代码包 runtime/debug 中的 SetMaxThreads 函数来限制 M 的最大值。</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>P 是 G 能够在 M 中运行的桥梁，Go 的运行时系统会适时的让 P 与不同的 M 建立或断开连接，使得 P 中的那些 G 能够及时获得运行时机，就像是操作系统内核在 CPU 之上的适时切换不同的进程和线程的场景类似<br>改变 P 的最大数量有两种方法：</p><ol><li>调用函数 runtime.GOMAXPROCS 传入参数的方式</li><li>在 Go 程序运行前设置环境变量 GOMAXPROCS 的值</li></ol><p>P 的最大值是 Go 程序并发规模的的限制。P 的数量即可运行的 G 的队列的数量。一个 G 被启动后，首先会被追加到某个 P 中的可运行 G 队列中，等待时机运行。<br>在设置 P 的最大值的时候，会检查该值的有效性，当前，Go 目前还不能保证在数量比 256 更多的 P 同时存在的情形下 Go 仍能保持高效，因此，只要不大于 256，都是被认为是有效的值。<br>一般情况下，P 设置为当前计算机的 CPU 核数。</p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>每个 G 代表一个 goroutine, 编程时，我们使用 go 语句只是提交了一个并发任务。而 Go 的运行时系统则会安装要求并发执行它。那么当执行 go 关键字的时候发生了什么呢？<br>Go 编译器会把 go 语句变成对内部函数 newproc (runtime.proc.go) 的调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func newproc(siz int32, fn *funcval) &#123;</span><br><span class="line">argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">pc := getcallerpc(unsafe.Pointer(&amp;siz))</span><br><span class="line">systemstack(func() &#123;</span><br><span class="line">newproc1(fn, (*uint8)(argp), siz, 0, pc)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正执行的函数在 newproc1(), 有需要请自行看源码，执行顺序如下：</p><ol><li>获得当前的 G 所在的 P，然后从空闲的 G 队列中取出一个 G</li><li>如果 1 取到则对这个 G 进行参数配置，否则新建一个G</li><li>将 G 加入 P 的可运行的 G 队列</li></ol><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>在 Go 语言中，调度器的主要调度对象就是 M, P, G 的实例。调度器在调度过程中需要依赖全局的调度对象的容器。简单来说，为了方便调度，调度器会对 M,P,G 的实例存储在容器中。<br>调度器的容器包括：</p><ul><li>调度器的空闲 M 列表：存放空闲的 M 的单向链表</li><li>调度器的空闲 P 列表：存放空闲的 P 的单向链表</li><li>调度器的可运行 G 队列：存放可运行 G 的队列</li><li>调度器的自由 G 列表：存放自由的 G 的单向链表</li></ul><p>调度器有自己的数据结构，形成此结构的主要目的是更加方便的管理和调度各个核心元素的实例。</p><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>goroutine 的核心理念是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要以共享内存的方式来通信。应该以通信作为手段来共享内存</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 语言操作 mysql 建表问题的解决办法</title>
      <link href="/2018/02/05/go-mysql-create-table/"/>
      <url>/2018/02/05/go-mysql-create-table/</url>
      <content type="html"><![CDATA[<hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>开发中需要利用 go 读取 sql 文件自动创建表。</p><p>table.sql 文件内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `user`;</span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键ID&apos;,</span><br><span class="line">  `name` varchar(30) NOT NULL COMMENT &apos;姓名&apos;,</span><br><span class="line">  PRIMARY KEY (`user_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>go 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func createTable() (err error) &#123;</span><br><span class="line">host := &quot;127.0.0.1&quot;</span><br><span class="line">port := &quot;3306&quot;</span><br><span class="line">user := &quot;root&quot;</span><br><span class="line">pass := &quot;admin&quot;</span><br><span class="line">name := &quot;test&quot;</span><br><span class="line">sqlBytes, err = ioutil.ReadFile(&quot;docs/databases/table.sql&quot;);</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">sqlTable := string(sqlBytes);</span><br><span class="line">fmt.Println(sqlTable)</span><br><span class="line">db, err := sql.Open(&quot;mysql&quot;, user+&quot;:&quot;+pass+&quot;@tcp(&quot;+host+&quot;:&quot;+port+&quot;)/&quot;+name+&quot;?charset=utf8&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer db.Close()</span><br><span class="line">_, err = db.Exec(sqlTable)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行，出错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right </span><br><span class="line">syntax to use near &apos;CREATE TABLE `user` (`user_id` int(11) NOT NULL AUTO_INCREMENT COMMEN&apos; at line 1</span><br></pre></td></tr></table></figure></p><p>刚开始是以为 sql 语句本身有问题，所以将 sql 语句直接粘贴到 mysql 命令行执行，成功。所以不是 sql 语句的问题。</p><p>查找资料才知道原因是 mysql 默认是不能在一个语句中同时执行两条 sql 语句，把 drop table 和 create table 拆开。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>将 多条 sql 语句拆开，每个语句单独执行 db.Exec()</li><li>查看 go-sql-driver 的文档，发现可以支持一条语句多条 sql 执行。修改代码如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err := sql.Open(&quot;mysql&quot;, user+&quot;:&quot;+pass+&quot;@tcp(&quot;+host+&quot;:&quot;+port+&quot;)/&quot;+name+&quot;?charset=utf8&amp;multiStatements=true&quot;)</span><br></pre></td></tr></table></figure></li></ol><p>增加了 &amp;multiStatements=true 参数</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHPUnit 学习实例代码</title>
      <link href="/2017/10/20/PHPUnit-Lean1/"/>
      <url>/2017/10/20/PHPUnit-Lean1/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>PHPUnit 基本用法+实例详解<br>上一篇文章介绍了 PHPUnit 在 windows  的安装和配置。今天我们来介绍一下 PHPUnit 如何编写一些基本的测试用例。我也是在最近才开始慢慢使用的 PHPUnit , 用不足之处，欢迎指正。</p></blockquote><h1 id="编写规范"><a href="#编写规范" class="headerlink" title="编写规范"></a>编写规范</h1><ol><li>测试类一般以***Test 命名；</li><li>该类必须继承 PHPUnit_Framework_TestCase 类；</li><li>类里的测试用例方法一般以test开头，当然也可以通过@test注释来定义一个名字不为test开头的方法为测试方法；</li><li>测试方法中需要使用断言方法来断言实际传入的参数与期望的参数是否一致来达到测试的目的；</li></ol><a id="more"></a><h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><ol><li>基本的demo</li></ol><p>定义一个类 DemoTest 并保存到 DemoTest.php 文件中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * phpunit test demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> phachon@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Framework_TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * test</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPushAndPop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $stack = <span class="keyword">array</span> ();</span><br><span class="line">        <span class="comment">//断言 $stack 的长度为0</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;assertEquals(<span class="number">0</span>, count($stack));</span><br><span class="line">        array_push($stack, <span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//断言 $stack 的长度为 1</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;assertEquals(<span class="number">1</span>, count($stack));</span><br><span class="line">        <span class="comment">//断言 $stack 的最后一个值为foo</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;assertEquals(<span class="string">'foo'</span>, $stack[count($stack)<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">//断言 $stack 出栈的值为 foo</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;assertEquals(<span class="string">'foo'</span>, array_pop($stack));</span><br><span class="line">        <span class="comment">//断言 $stack 的长度为 0</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;assertEquals(<span class="number">0</span>, count($stack));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义test标签来声明是测试方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@test</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">indexEquals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $stack = <span class="keyword">array</span> (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//断言 $stack 索引 0 的值为2</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;assertEquals(<span class="number">2</span>, $stack[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了两种测试用例的方法，一种是开头为test, 一种是定义@test标签；两种都可以。<br>然后运行测试这个类；打开命令窗口，进入该代码保存的文件目录输入:phpunit DemoTest.php<br>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Time:825 ms, Memory: 8.25Mb</span><br><span class="line">There was 1 failure:</span><br><span class="line">1) DemoTest::indexEquals</span><br><span class="line">Failed asserting that 0 matches expected 2.</span><br><span class="line">D:\server\apache\htdocs\my_php_code\phpunit\stack\DemoTest.php:32</span><br><span class="line">FAILURES!</span><br><span class="line">Tests: 2, Assertions: 6, Failures: 1.</span><br></pre></td></tr></table></figure><p>解释一下：最上面的是一些耗时，内存消耗的多少。往下看测试结果说有一个错误，也就是测试未通过，在文件的32行。32行的意思是断言这个数组中索引为0的值为2，显然不是，这里我故意写错，所以测试失败。如果改为0则会显示OK;最后是显示2个测试用例，6个断言，其中一个失败。</p><ol start="2"><li>方法依赖关系</li></ol><p>在测试类中，测试用例方法可以有依赖关系。通过依赖关系可以传一些参数到方法中；因为默认的测试用例方法是不能有参数的。<br>定义一个FunTest 类保存到文件中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试方法依赖关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> phachon@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FuncTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Framework_TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">$stack = <span class="keyword">array</span> ();</span><br><span class="line"><span class="keyword">$this</span>-&gt;assertEmpty($stack);</span><br><span class="line"><span class="keyword">return</span> $stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * depends 方法用来表示依赖的方法名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@depends</span> testEmpty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $stack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPush</span><span class="params">(array $stack)</span> </span>&#123;</span><br><span class="line">array_push($stack, <span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;assertEquals(<span class="string">'foo'</span>, $stack[count($stack)<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> $stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@depends</span> testPush</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPop</span><span class="params">(array $stack)</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;assertEquals(<span class="string">'foo'</span>, array_pop($stack));</span><br><span class="line"><span class="keyword">$this</span>-&gt;assertEmpty($stack);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签@depends是表示依赖关系，上面的代码中testPop()依赖testPush(),testPush()依赖testEmpty(), 所以当testEmpty()测试通过后返回的变量可以作为testPush(array $stack)的参数。同理，testPop()也是一样。<br>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time: 726 ms, Memory: 8.25Mb</span><br><span class="line">OK (3 tests, 4 assertions)</span><br></pre></td></tr></table></figure><p>测试通过</p><ol start="3"><li>测试非依赖关系的方法传入参数</li></ol><p>如果非依赖关系的方法，默认是不能有参数的，这个时候怎么样才能传参，PHPUnit 提供给了一个标签，@dataProvider<br>定义一个DataTest类保存到文件中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试非依赖关系的方法传入参数</span></span><br><span class="line"><span class="comment"> * 方法提供者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> phachon@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Framework_TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dataProvider 标签用来提供数据的方法名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dataProvider</span> add_provider</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testAdd</span><span class="params">($a, $b, $c)</span> </span>&#123;</span><br><span class="line"><span class="comment">//断言 a + b = c</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;assertEquals($c, $a + $b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据提供者的方法</span></span><br><span class="line"><span class="comment"> * 格式：</span></span><br><span class="line"><span class="comment"> * return array(</span></span><br><span class="line"><span class="comment"> *      array(参数1,参数2,参数3,参数4,参数N),</span></span><br><span class="line"><span class="comment"> *      array(参数1,参数2,参数3,参数4,参数N),</span></span><br><span class="line"><span class="comment"> * );</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add_provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">array</span> (</span><br><span class="line"><span class="keyword">array</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="keyword">array</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line"><span class="keyword">array</span> (<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line"><span class="keyword">array</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面代码应该就能明白。直接运行phpunit DataTest.php<br>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time: 379 ms, Memory: 8.25Mb</span><br><span class="line">OK (3 tests, 4 assertions)</span><br></pre></td></tr></table></figure><ol start="4"><li>数据提供者方法和依赖关系的限制</li></ol><p>这个听起来有点绕口，意思是如果方法依赖和方法提供者同时使用的话，是有限制的。说半天我估计还是一塌糊涂，不解释，直接看代码<br>定义一个 Data2Test 类保存到文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据提供者方法和依赖关系的限制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当一个测试方法依赖于另外一个使用data providers测试方法时,</span></span><br><span class="line"><span class="comment"> * 这个测试方法将会在它依赖的方法至少测试成功一次后运行,</span></span><br><span class="line"><span class="comment"> * 同时使用data providers的测试方法的执行的结果不能传入一个依赖它的测试方法中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> phachon@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2Test</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Framework_TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">78</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dataProvider</span> add_provider</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@depends</span> testB</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testB</span><span class="params">($a, $b, $c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;assertEquals($c, $a + $b);</span><br><span class="line"><span class="keyword">return</span> $a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@depneds</span> testB</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testC</span><span class="params">($a)</span> </span>&#123;</span><br><span class="line">var_dump($a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add_provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">array</span> (</span><br><span class="line"><span class="keyword">array</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="keyword">array</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line"><span class="keyword">array</span> (<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line"><span class="keyword">array</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下：<br>testB 依赖于 testA (testA 使用了dataProvider 提供数据)<br>如果 add_provider 提供的数据至少有一次是成功的，则在成功一次后运行 testC<br>如果 add_provider 提供的数据没有一次是成功的，则 testC 一次也不会执行<br>但是 testC 执行的结果永远是 null, 因为 $a 是通过 dataProvider 提供的。不能传入依赖它的测试方法中<br>好像还是不太明白，反正我是尽力了。慢慢理解吧。</p><ol start="5"><li>通过构造迭代器来为方法提供数据</li></ol><p>通过标签 @dataProvider 来直接返回数据作为数据提供者，PHPUnit 也可以通过返回构造器对象来提供数据。上代码<br>新建 IteratorTest.php 文件 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过构造迭代器来为方法提供数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> phachon@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> $_position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> $_array = <span class="keyword">array</span> (</span><br><span class="line"><span class="keyword">array</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="keyword">array</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line"><span class="keyword">array</span> (<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line"><span class="keyword">array</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_array[<span class="keyword">$this</span>-&gt;_position];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">key</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="number">2</span>;</span><br><span class="line">++<span class="keyword">$this</span>-&gt;_position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">valid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_array[<span class="keyword">$this</span>-&gt;_position]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_position = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Framework_TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dataProvider</span> add_provider</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testAdd</span><span class="params">($a, $b, $c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">$this</span>-&gt;assertEquals($c, $a + $b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add_provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> myIterator();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先定义了一个构造器，然后返回这个构造器对象，同样也能提供数据。运行 phpunit IteratorTest.php<br>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time: 408 ms, Memory: 8.25Mb</span><br><span class="line">OK (4 tests, 4 assertions)</span><br></pre></td></tr></table></figure><ol start="6"><li>异常测试</li></ol><p>有时候我们希望能够抛出我们所期待的异常。这里有三种方法来测试异常，上代码<br>定义 ThrowTest 类保存到文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试异常</span></span><br><span class="line"><span class="comment"> * 三种方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> phachon@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThrowTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Framework_TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.注释法: expectedException 期待的异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@expectedExeption</span> My_Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testException1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2.设定法：$this-&gt;setExpectedException 期待的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testException2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;setExpectedException(<span class="string">'My_Exception'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3.捕获法：try catch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testException3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (My_Exception $e) &#123;</span><br><span class="line"><span class="comment">//捕获到异常测试通过，否则失败</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">$this</span>-&gt;fail(<span class="string">'一个期望的异常没有被捕获'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码应该很明白了，不用解释了。</p><ol start="7"><li>错误测试</li></ol><p>有时候代码会发生错误，比如某个php文件找不到，文件不可读，php 文件加载失败等。这个时候我们也能进行测试，是否发生错误；PHPUnit 会把错误直接转化为异常PHPUnit_Framework_Error并抛出；我们要做到的是捕获这个异常。上代码。<br>定义 ErrorTest 类保存到文件中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误测试</span></span><br><span class="line"><span class="comment"> * phpunit 会把错误直接转化为异常PHPUnit_Framework_Error并抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Framework_TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 期待捕获 PHPUnit_Framework_Error 的异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@expectedException</span> PHPUnit_Framework_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testError</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果文件不存在就会抛出异常，我们需要捕获异常</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'../test.php'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试显示OK,则证明已经捕获。</p><ol start="8"><li>对输出进行测试</li></ol><p>有时候我们需要对程序的指定输出进行测试。比如echo 还是 print() 指定的值是否正确。<br>定义类 OutputTest 类保存到文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> phachon@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutputTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Framework_TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testExpectFooActualFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;expectOutputString(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">print</span> <span class="string">'foo'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testExpectBarActualBaz</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;expectOutputString(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">print</span> <span class="string">'baz'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: 在严格模式下，本身产生输出的测试将会失败。</p><ol start="9"><li>基镜（fixture）</li></ol><p>PHPUnit 支持共享建立基境的代码。在运行某个测试方法前，会调用一个名叫 setUp() 的模板方法。setUp() 是创建测试所用对象的地方。当测试方法运行结束后，不管是成功还是失败，都会调用另外一个名叫 tearDown() 的模板方法。tearDown() 是清理测试所用对象的地方。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixTureTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Framework_TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> $stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;stack = <span class="keyword">array</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;assertTrue(<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;stack));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">array_push(<span class="keyword">$this</span>-&gt;stack, <span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;assertEquals(<span class="string">'foo'</span>, <span class="keyword">$this</span>-&gt;stack[count(<span class="keyword">$this</span>-&gt;stack)<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">$this</span>-&gt;assertFalse(<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;stack));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">array_push(<span class="keyword">$this</span>-&gt;stack, <span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;assertEquals(<span class="string">'foo'</span>, array_pop(<span class="keyword">$this</span>-&gt;stack));</span><br><span class="line"><span class="keyword">$this</span>-&gt;assertTrue(<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;stack));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是PHPUnit 官方的一个代码示例。<br>测试类的每个测试方法都会运行一次 setUp() 和 tearDown() 模板方法（同时，每个测试方法都是在一个全新的测试类实例上运行的）。<br>另外，setUpBeforeClass() 与 tearDownAfterClass() 模板方法将分别在测试用例类的第一个测试运行之前和测试用例类的最后一个测试运行之后调用。</p><p>setUp() 多 tearDown() 少<br>理论上说，setUp() 和 tearDown() 是精确对称的，但是实践中并非如此。实际上，只有在 setUp() 中分配了诸如文件或套接字之类的外部资源时才需要实现 tearDown() 。如果 setUp() 中只创建纯 PHP 对象，通常可以略过 tearDown()。不过，如果在 setUp() 中创建了大量对象，你可能想要在 tearDown() 中 unset() 指向这些对象的变量，这样它们就可以被垃圾回收机制回收掉。对测试用例对象的垃圾回收动作则是不可预知的。 —PHPUnit 官方网站</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，今天大概就先介绍这些，已经可以大概写一些测试用例了。当然还有更高级的测试使用方法。现在为什么不讲呢，因为我也不会。。</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> PHPUnit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHPUnit windows 下的安装</title>
      <link href="/2017/10/20/PHPUnit-install-windows/"/>
      <url>/2017/10/20/PHPUnit-install-windows/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>本篇文章介绍一下 PHPUnit 在 windows 下的安装和配置</p></blockquote><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>php 版本 php5.4.45</li><li>phpunit 版本 phpunit4.8.24</li><li>操作系统：windows 7 (32)</li><li>php 安装（这里不再详细讲解）</li><li>phpunit 下载地址：<a href="https://phpunit.de/" target="_blank" rel="noopener">https://phpunit.de/</a> 下载到文件 phpunit-4.8.24.phar</li></ul><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li>将下载的 phpunit-4.8.24.phar 文件保存保存为phar到你自己设定的目录，如我的目录是D：\server\phpunit 下。</li><li>配置 path 环境变量；计算机右击属性—&gt;高级系统设置—&gt;环境变量–&gt; 在系统变量下找到 path 一栏，选中，编辑。添加 phpunit 路径;D:\server\phpunit  到最后。注意 ; 不要忘记。</li><li>按快捷键Win + R ，输入cmd并回车。打开 cmd 命令窗口，进入phpunit 的文件目录。D：\server\phpunit </li><li>输入 echo @php “%~dp0phpunit.phar” %* &gt; phpunit.cmd</li></ol><p>接着输入phpunit –version 并回车显示如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHPUnit 4.8.24 by Sebastian Bergmann and contributors</span><br></pre></td></tr></table></figure><p>表示安装成功。（如果有误，输入exit 并回车，重新来一遍）</p><p>注意：如果失败，请检查你的 php  path 变量是否配置</p><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><ul><li>–log-tap   生成TAP格式的日志文件</li><li>–log-dbus  使用DBUS记录测试的执行情况</li><li>–log-json  生成JSON格式的日志文件</li><li>–coverage-html 生成html格式的代码覆盖报告<br>请注意这个功能只能在tokenizer和Xdebug安装后才能使用</li><li>–coverage-clover 生成xml格式的代码覆盖报告<br>请注意这个功能只能在tokenizer和Xdebug安装后才能使用</li><li>–testdox-html and –testdox-text  生成记录已运行测试的html或者纯文本格式的文件文档</li><li>–filter 只运行名字符合参数规定的格式的测试，参数可以是一个测试的名字或者一个匹配多个测试名字的正则表达式</li><li>–group  只运行规定的测试组，一个测试可以使用@group注释来分组    @author注视是一个和@group关联的注释标签，用来根据作者来过滤测试</li><li>–exclude-group 只包含规定的多个测试组，一个测试可以使用@group注释来分组</li><li>–list-groups    列出可用的测试组</li><li>–loader 定义使用PHPUnit_Runner_TestSuiteLoader的接口</li><li>–repeat    根据定义的数字重复运行测试</li><li>–tap 使用Test Anything Protocol格式报告测试进程</li><li>–testdox    使用agile documentation格式报告测试进程</li><li>–colors     在输出结果中使用颜色</li><li>–stderr    使用STDERR替代STDOUT输出结果</li><li>–stop-on-error    在遇到第一个错误时停止执行</li><li>–stop-on-failure    在遇到第一个失败时停止执行</li><li>–stop-on-skipped       在遇到第一个跳过的测试时停止执行</li><li>–stop-on-incomplete       在遇到第一个未完成的测试时停止执行</li><li>–strict    当一个测试没有定义任何断言时将其标记为未完成的测试</li><li>–verbose    输出例如未完成的测试的名字，跳过的测试的名字</li><li>–wait    在每个测试开始之前等待用户按键，这个在你一个保持打开的窗口中运行很长的测试时很有帮助</li><li>–skeleton-class    从一个测试类中生成一个概要测试类</li><li>–skeleton-test    在Unit.php内为类Unit生成一个概要测试类UnitTest</li><li>–process-isolation      在多个php进程中运行所有测试</li><li>–no-globals-backup   不备份和还原$GLOBALS变量</li><li>–static-backup    备份和还原用户定义的类中的静态变量</li><li>–syntax-check    对测试的代码文件开启语法检查</li><li>–bootstrap    定义测试前运行的bootstrap的php文件的路径</li><li>–configuration, -c    从xml文件中读取配置，增加-c参数看更多的内容<br>如果phpunit.xml或phpunit.xml.dist(根据这个模式)在当前的目录中存在且–configuration参数没有使用的时候，配置信息会被自动读取</li><li>–no-configuration    自动跳过当前目录的phpunit.xml和phpunit.xml.dist配置文件</li><li>–include-path    在php的include_path增加路径</li><li>-d    定义php的配置属性</li><li>–debug    输出调试信息如测试的名称及该测试什么时候开始执行</li></ul><p>提示当测试代码中含有php语法错误的时候，测试器会退出且不会打印任何错误信息，standard test suite loader可选择性检查测试文件源代码的PHP语法错误，但是不会检查测试文件中引入的其他的代码文件的语法错误</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> PHPUnit </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 获取文件信息方法</title>
      <link href="/2017/10/10/go-fileinfo/"/>
      <url>/2017/10/10/go-fileinfo/</url>
      <content type="html"><![CDATA[<hr><p>最近一直在写 go 语言，总结下go获取文件信息的方法</p><h2 id="获取文件修改时间"><a href="#获取文件修改时间" class="headerlink" title="获取文件修改时间"></a>获取文件修改时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, _ := os.Stat(&quot;test.log&quot;)</span><br><span class="line">//修改时间</span><br><span class="line">modTime := fileInfo.ModTime()</span><br><span class="line">fmt.Println(modTime)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, err := os.Stat(&quot;test.log&quot;)</span><br><span class="line">if(os.IsNotExist(err)) &#123;</span><br><span class="line">fmt.Println(&quot;file not exist!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件是否是目录"><a href="#文件是否是目录" class="headerlink" title="文件是否是目录"></a>文件是否是目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, _ := os.Stat(&quot;test.log&quot;)</span><br><span class="line">//是否是目录</span><br><span class="line">isDir := fileInfo.IsDir()</span><br><span class="line">fmt.Println(isDir)</span><br></pre></td></tr></table></figure><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, _ := os.Stat(&quot;test.log&quot;)</span><br><span class="line">//权限</span><br><span class="line">mode := fileInfo.Mode()</span><br><span class="line">fmt.Println(mode)</span><br></pre></td></tr></table></figure><h2 id="获取文件名"><a href="#获取文件名" class="headerlink" title="获取文件名"></a>获取文件名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, _ := os.Stat(&quot;test.log&quot;)</span><br><span class="line">//文件名</span><br><span class="line">filename:= fileInfo.Name()</span><br><span class="line">fmt.Println(filename)</span><br></pre></td></tr></table></figure><h2 id="获取文件大小"><a href="#获取文件大小" class="headerlink" title="获取文件大小"></a>获取文件大小</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, _ := os.Stat(&quot;test.log&quot;)</span><br><span class="line">//文件大小</span><br><span class="line">filesize:= fileInfo.Size()</span><br><span class="line">fmt.Println(filesize)//返回的是字节</span><br></pre></td></tr></table></figure><h2 id="获取文件创建时间"><a href="#获取文件创建时间" class="headerlink" title="获取文件创建时间"></a>获取文件创建时间</h2><p>文件的创建时间并没有直接的方法返回，翻看源代码才知道如何获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, _ := os.Stat(&quot;test.log&quot;)</span><br><span class="line">fileSys := fileInfo.Sys().(*syscall.Win32FileAttributeData)</span><br><span class="line">nanoseconds := fileSys.CreationTime.Nanoseconds() // 返回的是纳秒</span><br><span class="line">createTime := nanoseconds/1e9 //秒</span><br><span class="line">fmt.Println(createTime)</span><br></pre></td></tr></table></figure><h2 id="文件最后写入时间"><a href="#文件最后写入时间" class="headerlink" title="文件最后写入时间"></a>文件最后写入时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, _ := os.Stat(&quot;test.log&quot;)</span><br><span class="line">fileSys := fileInfo.Sys().(*syscall.Win32FileAttributeData)</span><br><span class="line">nanoseconds := fileSys.LastWriteTime.Nanoseconds() // 返回的是纳秒</span><br><span class="line">lastWriteTime := nanoseconds/1e9 //秒</span><br><span class="line">fmt.Println(lastWriteTime)</span><br></pre></td></tr></table></figure><h2 id="文件最后访问时间"><a href="#文件最后访问时间" class="headerlink" title="文件最后访问时间"></a>文件最后访问时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, _ := os.Stat(&quot;test.log&quot;)</span><br><span class="line">fileSys := fileInfo.Sys().(*syscall.Win32FileAttributeData)</span><br><span class="line">nanoseconds := fileSys.LastAccessTime.Nanoseconds() // 返回的是纳秒</span><br><span class="line">lastAccessTime:= nanoseconds/1e9 //秒</span><br><span class="line">fmt.Println(lastAccessTime)</span><br></pre></td></tr></table></figure><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, _ := os.Stat(&quot;test.log&quot;)</span><br><span class="line">fileSys := fileInfo.Sys().(*syscall.Win32FileAttributeData)</span><br><span class="line">fileAttributes:= fileSys.FileAttributes</span><br><span class="line">fmt.Println(fileAttributes)</span><br></pre></td></tr></table></figure><p>介绍一个我用 go 写的日志管理包，地址： <a href="https://github.com/phachon/go-logger" target="_blank" rel="noopener">https://github.com/phachon/go-logger</a></p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Bootstrap html后台模板总结</title>
      <link href="/2017/09/13/bootstrap-html/"/>
      <url>/2017/09/13/bootstrap-html/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>总结的一些模板在个人的 github 地址，有需要的欢迎下载或 fork<br><a href="https://github.com/phachon/html-templates" target="_blank" rel="noopener">https://github.com/phachon/html-templates</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootstrap </tag>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>后端知识点总结</title>
      <link href="/2017/09/05/knowledage/"/>
      <url>/2017/09/05/knowledage/</url>
      <content type="html"><![CDATA[<hr><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><a href="https://github.com/ProgramingBooks/data-structure/blob/master/LinearList/SequenceList.md" target="_blank" rel="noopener">顺序表</a></li><li><a href="">链表</a><ul><li><a href="https://github.com/ProgramingBooks/data-structure/blob/master/LinearList/SinglyLinkedList.md" target="_blank" rel="noopener">单向链表</a></li><li><a href="https://github.com/ProgramingBooks/data-structure/blob/master/LinearList/DoublyLinkedList.md" target="_blank" rel="noopener">双向链表</a></li><li><a href="https://github.com/ProgramingBooks/data-structure/blob/master/LinearList/LoopLinkedList.md" target="_blank" rel="noopener">循环链表</a></li></ul></li><li>队列<ul><li><a href="https://github.com/ProgramingBooks/data-structure/blob/master/Queue/LoopQueue.md" target="_blank" rel="noopener">循环队列</a></li><li><a href="https://github.com/ProgramingBooks/data-structure/blob/master/Queue/LinkedQueue.md" target="_blank" rel="noopener">链队列</a></li></ul></li><li>栈<ul><li><a href="https://github.com/ProgramingBooks/data-structure/blob/master/Stack/SequenceStack.md" target="_blank" rel="noopener">顺序栈</a></li><li><a href="https://github.com/ProgramingBooks/data-structure/blob/master/Stack/LinkedStack.md" target="_blank" rel="noopener">链栈</a></li></ul></li><li><a href="">集合</a></li><li><a href="https://github.com/ProgramingBooks/data-structure/blob/master/Tree/README.md" target="_blank" rel="noopener">树</a><ul><li><a href="https://github.com/ProgramingBooks/data-structure/blob/master/Tree/BinaryTree.md" target="_blank" rel="noopener">二叉树</a></li><li><a href="https://www.cnblogs.com/liujinghuan/p/5842487.html" target="_blank" rel="noopener">二叉树遍历</a></li><li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html" target="_blank" rel="noopener">二叉查找树</a></li><li><a href="http://www.cnblogs.com/polly333/p/4798944.html" target="_blank" rel="noopener">平衡二叉树</a></li><li><a href="https://blog.csdn.net/sun_tttt/article/details/65445754" target="_blank" rel="noopener">红黑树</a></li><li><a href="https://blog.csdn.net/aqzwss/article/details/53074186" target="_blank" rel="noopener">B 树</a></li><li><a href="https://blog.csdn.net/dbanote/article/details/8897599" target="_blank" rel="noopener">LSM 树</a></li></ul></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li><a href="https://blog.csdn.net/jiangyanting2011/article/details/70325215/" target="_blank" rel="noopener">常见面试算法</a></li><li><a href="https://blog.csdn.net/eldn__/article/details/79797236" target="_blank" rel="noopener">算法</a></li><li><a href="http://baike.renwuyi.com/2018-02/22397.html" target="_blank" rel="noopener">常被问到的算法题</a></li><li><a href="https://cloud.tencent.com/developer/article/1011030" target="_blank" rel="noopener">面试算法题</a></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li><a href="https://blog.csdn.net/gane_cheng/article/details/52652705" target="_blank" rel="noopener">各种排序算法复杂度分析</a></li><li><a href="https://github.com/ProgramingBooks/algorithm/tree/master/Sort" target="_blank" rel="noopener">排序算法</a></li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li><a href="">二分查找</a></li><li><a href="https://blog.csdn.net/u014581901/article/details/50133913" target="_blank" rel="noopener">插值查找</a></li><li><a href="https://www.cnblogs.com/bethunebtj/p/4839576.html" target="_blank" rel="noopener">斐波那契查找</a></li><li><a href="">二叉查找树查找</a></li><li><a href="https://blog.csdn.net/sinat_33363493/article/details/52693668" target="_blank" rel="noopener">哈希查找</a></li></ul><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><ul><li><a href="https://www.cnblogs.com/yangjiannr/p/da-shu-ju-chu-libitmap.html" target="_blank" rel="noopener">大数据处理-Bitmap</a></li><li><a href="https://segmentfault.com/a/1190000002729689" target="_blank" rel="noopener">布隆过滤器</a></li><li><a href="https://blog.csdn.net/qq_30242609/article/details/71024458" target="_blank" rel="noopener">基于 Redis 的 Bitmap 数据结构</a></li><li><a href="https://blog.csdn.net/lemon_tree12138/article/details/47973715" target="_blank" rel="noopener">网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用</a></li></ul><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">KMP 字符串匹配</a></li></ul><h3 id="图遍历"><a href="#图遍历" class="headerlink" title="图遍历"></a>图遍历</h3><ul><li><a href="https://www.cnblogs.com/0kk470/p/7555033.html" target="_blank" rel="noopener">深度优先遍历和广度优先遍历</a></li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li><a href="https://www.cnblogs.com/MrSaver/p/8641971.html" target="_blank" rel="noopener">《算法：贪婪算法基础》</a></li><li><a href="https://blog.csdn.net/a345017062/article/details/52443781" target="_blank" rel="noopener">《常见算法及问题场景——贪心算法》</a></li></ul><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><ul><li><a href="https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368" target="_blank" rel="noopener">一致性哈希在Redis集群中的应用</a></li></ul><h2 id="网络知识"><a href="#网络知识" class="headerlink" title="网络知识"></a>网络知识</h2><ul><li><a href="https://www.cnblogs.com/Robin-YB/p/6668762.html" target="_blank" rel="noopener">七层协议</a></li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li><a href="https://www.cnblogs.com/onepixel/p/7092302.html" target="_blank" rel="noopener">TCP 协议</a></li><li><a href="https://blog.csdn.net/whuslei/article/details/6667471/" target="_blank" rel="noopener">TCP 三次握手</a></li><li><a href="https://blog.csdn.net/slforeverlove/article/details/47018015" target="_blank" rel="noopener">TCP 知识点总结</a></li><li><a href="https://www.cnblogs.com/obama/p/3292335.html" target="_blank" rel="noopener">TCP面试题集</a></li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li><a href="https://www.cnblogs.com/HPAHPA/p/7737531.html" target="_blank" rel="noopener">UDP 协议总结</a></li></ul><h3 id="KDP"><a href="#KDP" class="headerlink" title="KDP"></a>KDP</h3><ul><li><a href="https://blog.csdn.net/qq_36748278/article/details/80171575" target="_blank" rel="noopener">KCP 原理及源码解析</a></li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li><a href="https://www.cnblogs.com/wangning528/p/6388464.html" target="_blank" rel="noopener">Http 协议详细讲解</a></li><li><a href="https://www.cnblogs.com/gofighting/p/5421890.html" target="_blank" rel="noopener">Http1.0 和 Http1.1区别</a></li><li><a href="https://blog.csdn.net/zhuyiquan/article/details/69257126" target="_blank" rel="noopener">Http2.0 设计</a></li><li><a href="https://blog.csdn.net/u012657197/article/details/77877840" target="_blank" rel="noopener">Http2.0 二进制帧</a></li><li><a href="https://blog.csdn.net/zhuyiquan/article/details/69257126" target="_blank" rel="noopener">Http2.0 原理详细分析</a></li><li><a href="https://www.cnblogs.com/endlessdream/p/4699273.html" target="_blank" rel="noopener">Session 和 Cookie</a></li><li><a href="http://www.cnblogs.com/andy-zhou/p/5360107.html" target="_blank" rel="noopener">理解 Session 和 Cookie机制</a></li><li><a href="https://segmentfault.com/a/1190000007078606" target="_blank" rel="noopener">跨域问题</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域问题2</a></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li><a href="https://www.cnblogs.com/zhangshitong/p/6478721.html" target="_blank" rel="noopener">Https 通俗了解</a></li><li><a href="https://blog.csdn.net/hherima/article/details/52469267" target="_blank" rel="noopener">HTTPS协议详解(一)：HTTPS基础知识</a></li><li><a href="http://blog.csdn.net/hherima/article/details/52469360" target="_blank" rel="noopener">HTTPS协议详解(二)：TLS/SSL工作原理</a></li><li><a href="http://blog.csdn.net/hherima/article/details/52469488" target="_blank" rel="noopener">HTTPS协议详解(三)：PKI 体系</a></li><li><a href="http://blog.csdn.net/hherima/article/details/52469674" target="_blank" rel="noopener">HTTPS协议详解(四)：TLS/SSL握手过程</a></li><li><a href="http://blog.csdn.net/hherima/article/details/52469787" target="_blank" rel="noopener">HTTPS协议详解(五)：HTTPS性能与优化</a></li></ul><h2 id="进程线程协程"><a href="#进程线程协程" class="headerlink" title="进程线程协程"></a>进程线程协程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li><a href="">进程的概念</a></li><li><a href="https://www.jianshu.com/p/9218692cb209" target="_blank" rel="noopener">进程间的同步机制</a></li><li><a href="https://www.cnblogs.com/Anker/p/3271773.html" target="_blank" rel="noopener">僵尸进程</a></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li><a href="">线程的基本概念</a></li><li><a href="https://blog.csdn.net/gatieme/article/details/51892437" target="_blank" rel="noopener">线程的三种实现方式</a></li><li><a href="https://www.cnblogs.com/losing-1216/p/5083097.html" target="_blank" rel="noopener">进程和线程的区别和联系</a></li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li><a href="https://www.tuicool.com/articles/BNvUfeb" target="_blank" rel="noopener">协程的历史，现在和未来</a></li><li><a href="https://www.cnblogs.com/diegodu/p/5607627.html" target="_blank" rel="noopener">以goroutine为例看协程的相关概念</a></li><li><a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="noopener">PHP中协程的使用</a></li></ul><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul><li><a href="https://www.cnblogs.com/liujiacai/p/7605612.html" target="_blank" rel="noopener">学习MySQL优化原理，这一篇就够了</a></li><li><a href="https://www.cnblogs.com/wmbg/p/6800354.html" target="_blank" rel="noopener">数据库优化</a></li><li><a href="https://blog.csdn.net/qq_39322743/article/details/79701420" target="_blank" rel="noopener">mysql面试</a></li><li><a href="http://app.myzaker.com/news/article.php?pk=5a114dd51bc8e03a2d000007" target="_blank" rel="noopener">mysql面试集锦</a></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li><a href="https://blog.csdn.net/hjm4702192/article/details/80518856" target="_blank" rel="noopener">Redis总结</a></li><li><a href="https://blog.csdn.net/wcf373722432/article/details/78678504" target="_blank" rel="noopener">Redis底层原理</a></li><li><a href="https://blog.csdn.net/l_bestcoder/article/details/79336986" target="_blank" rel="noopener">Redis 实现分布式锁</a></li><li><a href="https://www.cnblogs.com/wenxiong/p/3954174.html" target="_blank" rel="noopener">PHP Redis实现分布式锁</a></li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul><li><a href="https://blog.csdn.net/dreamchasering/article/details/77653512" target="_blank" rel="noopener">RabbitMQ基础知识详解</a></li><li><a href="https://blog.csdn.net/samxx8/article/details/47417133" target="_blank" rel="noopener">RabbitMQ概念总结</a></li><li><a href="http://www.cnblogs.com/vipstone/p/9275256.html" target="_blank" rel="noopener">深入了解RabbitMQ</a></li></ul><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul><li><a href="https://www.cnblogs.com/linguoguo/p/5511293.html" target="_blank" rel="noopener">Nginx原理和优化</a></li><li><a href="https://blog.csdn.net/u010209217/article/details/77854929" target="_blank" rel="noopener">Nginx基础配置详解</a></li><li><a href="https://blog.csdn.net/qq_25797077/article/details/52200722" target="_blank" rel="noopener">Nginx基本学习</a></li></ul><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><ul><li><a href="https://www.cnblogs.com/ghosth/p/7502197.html" target="_blank" rel="noopener">浅析 Apache 工作原理</a></li><li><a href="https://blog.csdn.net/hguisu/article/details/7395181" target="_blank" rel="noopener">Apache运行机制剖析</a></li><li><a href="https://www.cnblogs.com/cunkouzh/p/5410154.html" target="_blank" rel="noopener">Nginx与Apache的对比及优缺点</a></li></ul><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><ul><li><a href="https://blog.csdn.net/zls986992484/article/details/52737974" target="_blank" rel="noopener">基本使用</a></li><li><a href="https://blog.csdn.net/chenleixing/article/details/47035453" target="_blank" rel="noopener">深入理解 memcache 原理</a></li><li><a href="https://www.cnblogs.com/JavaBlackHole/p/7726195.html" target="_blank" rel="noopener">Redis和Memcache区别，优缺点对比</a></li></ul><h3 id="Sphinx"><a href="#Sphinx" class="headerlink" title="Sphinx"></a>Sphinx</h3><ul><li><a href="https://blog.csdn.net/yk19851111/article/details/51553351" target="_blank" rel="noopener">Sphinx 的介绍和原理探索</a></li><li><a href="https://blog.csdn.net/phachon/article/details/52451000" target="_blank" rel="noopener">Sphinx 在网站架构中的应用</a></li></ul><h3 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h3><ul><li><a href="https://blog.csdn.net/wenlixing110/article/details/56277603" target="_blank" rel="noopener">ELK多种架构及优势</a></li></ul><h2 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><a href="https://studygolang.com/articles/10065" target="_blank" rel="noopener">常见知识点</a></li><li><a href="https://goquiz.github.io/" target="_blank" rel="noopener">笔试网站</a></li><li><a href="https://studygolang.com/articles/1642" target="_blank" rel="noopener">make和new区别</a></li><li><a href="https://studygolang.com/articles/13359?fr=sidebar" target="_blank" rel="noopener">golang中的引用类型</a></li></ul><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><ul><li><a href="https://blog.csdn.net/zhonglinzhang/article/details/74626412" target="_blank" rel="noopener">内存分配与管理</a></li><li><a href="https://www.cnblogs.com/ldaniel/p/8502867.html?utm_source=debugrun&amp;utm_medium=referral" target="_blank" rel="noopener">内存管理</a></li><li><a href="https://blog.csdn.net/qq_17612199/article/details/80278632" target="_blank" rel="noopener">内存管理和垃圾回收</a></li><li><a href="https://phachon.com/2018/09/09/go_bootstrap/" target="_blank" rel="noopener">go语言启动过程</a></li><li><a href="https://phachon.com/2018/09/03/go_concurrent/" target="_blank" rel="noopener">go语言并发机制</a></li><li><a href="https://studygolang.com/articles/1855" target="_blank" rel="noopener">go 调度器</a></li><li><a href="https://blog.csdn.net/m0_37579159/article/details/79345831" target="_blank" rel="noopener">golang并发原理分析</a></li><li><a href="https://blog.csdn.net/pmlpml/article/details/78850661" target="_blank" rel="noopener">理解 goroutine 的并发</a></li><li><a href="https://blog.csdn.net/liangzhiyang/article/details/52669851" target="_blank" rel="noopener">Goroutine调度机制</a></li><li><a href="http://www.cnblogs.com/williamjie/p/9267741.html" target="_blank" rel="noopener">Goroutine并发调度模型深度解析之手撸一个协程池</a></li><li><a href="https://blog.csdn.net/screscent/article/details/79697992" target="_blank" rel="noopener">fasthhtp 的优化</a></li><li><a href="https://wangzhezhe.github.io/2017/02/12/go-routine-using-scenarios/" target="_blank" rel="noopener">channel的底层实现</a></li><li><a href="https://blog.csdn.net/justaipanda/article/details/43155949" target="_blank" rel="noopener">深入理解 interface</a></li></ul><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><ul><li><a href="https://gitee.com/phachon/review-information/tree/master/php" target="_blank" rel="noopener">基本知识点总结</a></li></ul><h2 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h2><h3 id="实现短网址项目"><a href="#实现短网址项目" class="headerlink" title="实现短网址项目"></a>实现短网址项目</h3><p><a href="https://www.jianshu.com/p/43eea66a2235" target="_blank" rel="noopener">https://www.jianshu.com/p/43eea66a2235</a><br><a href="https://www.cnblogs.com/lovekingly/p/5505308.html" target="_blank" rel="noopener">https://www.cnblogs.com/lovekingly/p/5505308.html</a><br><a href="https://www.jb51.net/article/136554.htm" target="_blank" rel="noopener">https://www.jb51.net/article/136554.htm</a><br><a href="https://www.cnblogs.com/flying1819/articles/8832640.html" target="_blank" rel="noopener">https://www.cnblogs.com/flying1819/articles/8832640.html</a></p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>火狐浏览器下刷新不清除表单问题</title>
      <link href="/2016/12/30/firefox-input/"/>
      <url>/2016/12/30/firefox-input/</url>
      <content type="html"><![CDATA[<hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>js 控制表单重新刷新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.href = url;</span><br><span class="line">location.reload();</span><br></pre></td></tr></table></figure><p>测试时发现谷歌，360均正常，但是在火狐浏览器，刷新完之后，表单的数据还在，并没有清除，刚开始以为是浏览器的设置问题。查找资料后找到一些解决办法</p><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>form 表单加参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot; autocomplete=&quot;off&quot; action=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocomplete=&quot;off&quot; 加了之后火狐刷新不再携带原始数据,清空表单</span><br></pre></td></tr></table></figure><p>ok，测试通过，完美解决</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html </tag>
            
            <tag> FireFox </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个基于 node.js 搭建的web聊天系统</title>
      <link href="/2016/10/11/phaChat/"/>
      <url>/2016/10/11/phaChat/</url>
      <content type="html"><![CDATA[<hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>一个简单的 web 聊天室, 采用 node.js 编写，基于 express + mysql + socket 实现的在线多人web 聊天系统，包括用户的登陆注册，用户的个人信息修改,目的是为了更加深入学习了解 node.js 和 websocket 技术，给初学者一个练习的小项目。有兴趣的同学可以继续完善（用户的头像上传，创建聊天群，消息保存等）</p></blockquote><a id="more"></a><h2 id="Install-安装"><a href="#Install-安装" class="headerlink" title="Install 安装"></a>Install 安装</h2><ul><li><p>环境<br>npm 3.<em><br>node v6.</em><br>express 4.3.<em><br>mysql 5.5.</em><br>redis 2.8.*</p></li><li><p>使用</p></li></ul><p>进入根目录，phaChat</p><pre><code>npm installnpm start //开启聊天室客户端node server //开启聊天室服务端</code></pre><p>浏览器输入 <a href="http://127.0.0.1:3000/chat/index" target="_blank" rel="noopener">http://127.0.0.1:3000/chat/index</a>,</p><h2 id="界面效果"><a href="#界面效果" class="headerlink" title="界面效果"></a>界面效果</h2><p>注册</p><p><img src="http://img.blog.csdn.net/20161011181034598" alt="这里写图片描述"></p><p>登录</p><p><img src="http://img.blog.csdn.net/20161011181057918" alt="这里写图片描述"></p><p>聊天室</p><p><img src="http://img.blog.csdn.net/20161011181119231" alt="这里写图片描述"></p><h2 id="继续扩展"><a href="#继续扩展" class="headerlink" title="继续扩展"></a>继续扩展</h2><ul><li>创建聊天室</li><li>用户修改头像</li><li>发送表情</li><li>model层优化</li></ul><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/phachon/phaChat" target="_blank" rel="noopener">https://github.com/phachon/phaChat</a></p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Node </tag>
            
            <tag> Express </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ELK 实时日志分析系统平台的学习与使用</title>
      <link href="/2016/09/22/elk-install/"/>
      <url>/2016/09/22/elk-install/</url>
      <content type="html"><![CDATA[<hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>工作工程中，不论是开发还是运维，都会遇到各种各样的日志，主要包括系统日志、应用程序日志和安全日志，对于开发人员来说，查看日志，可以实时查看程序的运行错误，以及性能分析，通常，一个大中型的应用程序会被部署到多台服务器，那日志文件也会分散到不同的机器上，这样查看日志难道要一台一台去查看？显然是太麻烦了，开源的日志分析系统 ELK 完美的解决了这个问题。<br>ELK  并不是一个独立的系统，她是由 ElasticSearch、Logstash、Kibana 三个开源的工具组成。</p><ul><li>ElasticSearch<br>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</li><li>Logstash<br>Logstash 是一个开源的日志分析、收集工具，并将日志存储以供以后使用。</li><li>Kibana<br>Kibana 是一个为 Logstash 和 ElasticSearch 提供的日志分析的 Web 接口。可使用它对日志进行高效的搜索、可视化、分析等各种操作。</li></ul><a id="more"></a><h2 id="搭建方法"><a href="#搭建方法" class="headerlink" title="搭建方法"></a>搭建方法</h2><p>基于一台主机的搭建，没有使用多台集群，logstah 收集日志后直接写入 elasticseach，可以用 redis 来作为日志队列</p><h3 id="jdk-安装"><a href="#jdk-安装" class="headerlink" title="jdk 安装"></a>jdk 安装</h3><p>jdk 1.8 安装</p><h3 id="elasticseach-安装"><a href="#elasticseach-安装" class="headerlink" title="elasticseach 安装"></a>elasticseach 安装</h3><p>下载地址：<a href="https://www.elastic.co/downloads，选择相应的版本" target="_blank" rel="noopener">https://www.elastic.co/downloads，选择相应的版本</a> 我这里的版本是 elasticsearch-2.4.0</p><p>解压目录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[phachon@localhost elk]$ tar -zxf elasticsearch-2.4.0</span><br><span class="line">[phachon@localhost elasticsearch-2.4.0]$</span><br><span class="line"># 安装 head 插件</span><br><span class="line">[phachon@localhost elasticsearch-2.4.0]$./bin/plugin install mobz/elasticsearch-head</span><br><span class="line">[phachon@localhost elasticsearch-2.4.0]$ ls plugins/</span><br><span class="line">head</span><br><span class="line">编辑 elasticseach 的配置文件</span><br><span class="line"></span><br><span class="line">[phachon@localhost elasticsearch-2.4.0]$ vim config/elasticseach.yml</span><br><span class="line">13 # ---------------------------------- Cluster -----------------------------------</span><br><span class="line">14 #</span><br><span class="line">15 # Use a descriptive name for your cluster:</span><br><span class="line">16 #</span><br><span class="line">17  cluster.name: es_cluster #这里是你的el集群的名称</span><br><span class="line">18 #</span><br><span class="line">19 # ------------------------------------ Node ------------------------------------</span><br><span class="line">20 #</span><br><span class="line">21 # Use a descriptive name for the node:</span><br><span class="line">22 #</span><br><span class="line">23  node.name: node0 # elseach 集群中的节点</span><br><span class="line">24 #</span><br><span class="line">25 # Add custom attributes to the node:</span><br><span class="line">26 #</span><br><span class="line">27 # node.rack: r1</span><br><span class="line">28 #</span><br><span class="line">29 # ----------------------------------- Paths ------------------------------------</span><br><span class="line">30 #</span><br><span class="line">31 # Path to directory where to store the data (separate multiple locations by comma):</span><br><span class="line">32 #</span><br><span class="line">33  path.data: /tmp/elasticseach/data #设置 data 目录</span><br><span class="line">34 #</span><br><span class="line">35 # Path to log files:</span><br><span class="line">36 #</span><br><span class="line">37  path.logs: /tmp/elasticseach/logs # 设置 logs 目录</span><br><span class="line">#</span><br><span class="line">39 # ----------------------------------- Memory -----------------------------------</span><br><span class="line">40 #</span><br><span class="line">41 # Lock the memory on startup:</span><br><span class="line">42 #</span><br><span class="line">43 # bootstrap.memory_lock: true</span><br><span class="line">44 #</span><br><span class="line">45 # Make sure that the `ES_HEAP_SIZE` environment variable is set to about half the memory</span><br><span class="line">46 # available on the system and that the owner of the process is allowed to use this limit.</span><br><span class="line">47 #</span><br><span class="line">48 # Elasticsearch performs poorly when the system is swapping the memory.</span><br><span class="line">49 #</span><br><span class="line">50 # ---------------------------------- Network -----------------------------------</span><br><span class="line">51 #</span><br><span class="line">52 # Set the bind address to a specific IP (IPv4 or IPv6):</span><br><span class="line">53 #</span><br><span class="line">54 # network.host: 192.168.0.1</span><br><span class="line">55  network.host: 192.168.30.128  # 这里配置本机的 ip 地址,这个是我的虚拟机的 ip </span><br><span class="line">56 #</span><br><span class="line">57 # Set a custom port for HTTP:</span><br><span class="line">58 #</span><br><span class="line">59  http.port: 9200 # 默认的端口</span><br></pre></td></tr></table></figure></p><p>其他配置可先不设置<br>启动 elstaicseach</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost elasticsearch-2.4.0]$ ./bin/elasticsearch</span><br></pre></td></tr></table></figure><p>注意，这里肯定会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost elasticsearch-2.4.0]# ./bin/elasticsearch</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: don&apos;t run elasticsearch as root.</span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:94)</span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:160)</span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:286)</span><br><span class="line">at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:35)</span><br><span class="line">Refer to the log for complete error details.</span><br></pre></td></tr></table></figure><p>之前在网上搜的教程这里都没有详细说明，导致花了很长时间卡在这里安装不成功。<br>提示的原因已经说的很清楚了，不能以 root 权限来安装 elasticseach<br>为 elsearch 添加专门的用户组和用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost elasticsearch-2.4.0]# groupadd elsearch</span><br><span class="line">[root@localhost elasticsearch-2.4.0]# adduser -G elsearch elsearch</span><br><span class="line">[root@localhost elasticsearch-2.4.0]# passwd elsearch 123456</span><br></pre></td></tr></table></figure><p>将 elasticseach 的安装目录设置为 elsearch 用户组和用户所有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost elk]# chown -R elsearch:elsearch elasticsearch-2.4.0/</span><br></pre></td></tr></table></figure><p>别忘了将 /tmp/elasticseach/data 和 /tmp/elasticseach/logs 目录也设置为 elsearch 用户所有,要不然会没有权限读写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost tmp]# chown -R elsearch:elsearch elasticseach/</span><br></pre></td></tr></table></figure><p>好了。终于设置完毕。切换到 elsearch 重新启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[elsearch@localhost elasticsearch-2.4.0]# ./bin/elasticsearch</span><br><span class="line">[2016-09-22 01:51:42,102][WARN ][bootstrap] unable to install syscall filter: seccomp unavailable: requires kernel 3.5+ </span><br><span class="line">with CONFIG_SECCOMP andCONFIG_SECCOMP_FILTER compiled in</span><br><span class="line">[2016-09-22 01:51:42,496][INFO ][node] [node0] version[2.4.0], pid[4205], build[ce9f0c7/2016-08-29T09:14:17Z]</span><br><span class="line">[2016-09-22 01:51:42,496][INFO ][node] [node0] initializing ...</span><br><span class="line">[2016-09-22 01:51:43,266][INFO ][plugins] [node0] modules [reindex, lang-expression, lang-groovy], plugins [head], </span><br><span class="line">sites [head]</span><br><span class="line">[2016-09-22 01:51:43,290][INFO ][env] [node0] using [1] data paths, mounts [[/ (/dev/sda5)]], net usable_space [8.4gb], </span><br><span class="line">net total_space [14.6gb], spins?[possibly], types [ext4]</span><br><span class="line">[2016-09-22 01:51:43,290][INFO ][env] [node0] heap size [998.4mb], compressed ordinary object pointers [unknown]</span><br><span class="line">[2016-09-22 01:51:43,290][WARN ][env] [node0] max file descriptors [4096] for elasticsearch process likely too low, consider </span><br><span class="line">increasing to at least[65536]</span><br><span class="line">[2016-09-22 01:51:45,697][INFO ][node] [node0] initialized</span><br><span class="line">[2016-09-22 01:51:45,697][INFO ][node] [node0] starting ...</span><br><span class="line">[2016-09-22 01:51:45,832][INFO ][transport] [node0] publish_address &#123;192.168.30.128:9300&#125;, bound_addresses &#123;192.168.30.128:9300&#125;</span><br><span class="line">[2016-09-22 01:51:45,839][INFO ][discovery] [node0] es_cluster/kJMDfFMwQXGrigfknNs-_g</span><br><span class="line">[2016-09-22 01:51:49,039][INFO ][cluster.service] [node0] new_master &#123;node0&#125;&#123;kJMDfFMwQXGrigfknNs-_g&#125;&#123;192.168.30.128&#125;</span><br><span class="line">&#123;192.168.30.128:9300&#125;, reason:zen-disco-join(elected_as_master, [0] joins received)</span><br><span class="line">[2016-09-22 01:51:49,109][INFO ][http] [node0] publish_address &#123;192.168.30.128:9200&#125;, bound_addresses &#123;192.168.30.128:9200&#125;</span><br><span class="line">[2016-09-22 01:51:49,109][INFO ][node] [node0] started</span><br><span class="line">[2016-09-22 01:51:49,232][INFO ][gateway] [node0] recovered [2] indices into cluster_state</span><br></pre></td></tr></table></figure><p>启动成功<br>在本机浏览器访问 <a href="http://192.168.30.128:9200" target="_blank" rel="noopener">http://192.168.30.128:9200</a></p><p><img src="http://img.blog.csdn.net/20160922113309605" alt="这里写图片描述"></p><p>说明搜索引擎 API 返回正常。注意要在服务器将 9200 端口打开，否则访问失败。</p><p>打开我们刚刚安装的 head 插件<br><a href="http://192.168.30.128:9200/_plugin/head/" target="_blank" rel="noopener">http://192.168.30.128:9200/_plugin/head/</a></p><p><img src="http://img.blog.csdn.net/20160922113529720" alt="这里写图片描述"></p><p>如果是第一次搭建好，里面是没有数据的，node0 节点也没有集群信息，这里我搭建完成后已经添加了数据。所以显示的有信息</p><h3 id="Logstash安装"><a href="#Logstash安装" class="headerlink" title="Logstash安装"></a>Logstash安装</h3><p>下载地址：<a href="https://www.elastic.co/downloads，选择相应的版本" target="_blank" rel="noopener">https://www.elastic.co/downloads，选择相应的版本</a> 我这里的版本是 logstash-2.4.0.tar.gz<br>解压目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost elk]# tar -zxvf logstash-2.4.0</span><br><span class="line">[root@localhost elk]# cd logstash-2.4.0</span><br></pre></td></tr></table></figure><p>编辑 logstash 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost logstash-2.4.0]# mkdir config</span><br><span class="line">[root@localhost logstash-2.4.0]# vim config/logstash.conf</span><br></pre></td></tr></table></figure><p>这里因为为了简单来显示一下数据，我这里将 apache 的日志作为数据源，也就是 logstash 的 input，直接输出到 elstaticseach 里，即 ouput</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">     # For detail config for log4j as input,</span><br><span class="line">     # See: https://www.elastic.co/guide/en/logstash/</span><br><span class="line">     file &#123;</span><br><span class="line">           type =&gt; &quot;apache-log&quot; # log 名</span><br><span class="line">           path =&gt; &quot;/etc/httpd/logs/access_log&quot; # log 路径</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    #Only matched data are send to output. 这里主要是用来过滤数据</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">   # For detail config for elasticsearch as output,</span><br><span class="line">   # See: https://www.elastic.co/guide/en/logstash/current</span><br><span class="line">   elasticsearch &#123;</span><br><span class="line">     action =&gt; &quot;index&quot;          #The operation on ES</span><br><span class="line">     hosts  =&gt; &quot;192.168.30.128:9200&quot;   #ElasticSearch host, can be array. # elasticseach 的 host </span><br><span class="line">     index  =&gt; &quot;apachelog&quot;         #The index to write data to. </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令来检测配置文件是否正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost logstash-2.4.0]# ./bin/logstash -f config/logstash.conf --configtest</span><br><span class="line">Configuration OK</span><br></pre></td></tr></table></figure><p>启动 logstash 来收集日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost logstash-2.4.0]# ./bin/logstash -f config/logstash.conf</span><br><span class="line">Settings: Default pipeline workers: 4</span><br><span class="line">Pipeline main started</span><br></pre></td></tr></table></figure><p>好了，logstash 可以开始收集日志了，当日志文件有变化时，会动态的写入到 elastaticseach 中，先让我们来产生一些日志吧。<br>刷新 <a href="http://192.168.30.128/" target="_blank" rel="noopener">http://192.168.30.128/</a> 一直刷新，apache 产生访问日志。ok，打开我们的 elasticseach 的 web 页面 <a href="http://192.168.30.128:9200/_plugin/head/" target="_blank" rel="noopener">http://192.168.30.128:9200/_plugin/head/</a></p><p><img src="http://img.blog.csdn.net/20160922113659904" alt="这里写图片描述"></p><p>这里就出现了我们刚刚配置的 apachelog 的日志，点开数据浏览</p><p><img src="http://img.blog.csdn.net/20160922113728826" alt="这里写图片描述"></p><p>这里很详细的列出了我们的日志文件，还有字段，左边可进行相应的搜索，右边点击可查看具体的日志信息。<br>至此我们已经能够收集日志，并进行搜索，接下来我们来将搜索数据可视化成图表</p><h3 id="Kibana-的安装"><a href="#Kibana-的安装" class="headerlink" title="Kibana 的安装"></a>Kibana 的安装</h3><p>下载：<a href="https://www.elastic.co/downloads" target="_blank" rel="noopener">https://www.elastic.co/downloads</a> 对应自己的版本, 这里我的版本是：kibana-4.6.1-linux-x86</p><p>解压目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost elk]# tar -zxvf kibana-4.6.1-linux-x86</span><br><span class="line">[root@localhost elk]# cd kibana-4.6.1-linux-x86</span><br></pre></td></tr></table></figure><p>编辑配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> [root@localhost kibana-4.6.1-linux-x86]# vim config/kibana.yml</span><br><span class="line"> # Kibana is served by a back end server. This controls which port to use.</span><br><span class="line"> server.port: 5601  # kibaba 服务 port </span><br><span class="line"> # The host to bind the server to.</span><br><span class="line"> server.host: &quot;192.168.30.128&quot;  # 你的kibaba 的服务host</span><br><span class="line"> # If you are running kibana behind a proxy, and want to mount it at a path,</span><br><span class="line"> # specify that path here. The basePath can&apos;t end in a slash.</span><br><span class="line"> # server.basePath: &quot;&quot;</span><br><span class="line"> # The maximum payload size in bytes on incoming server requests.</span><br><span class="line"> # server.maxPayloadBytes: 1048576</span><br><span class="line"> # The Elasticsearch instance to use for all your queries.</span><br><span class="line"> elasticsearch.url: &quot;http://192.168.30.128:9200&quot;  # elastaticseach 的host</span><br><span class="line"> # preserve_elasticsearch_host true will send the hostname specified in `elasticsearch`. If you set it to false,</span><br><span class="line"> # then the host you use to connect to *this* Kibana instance will be sent.</span><br><span class="line"> # elasticsearch.preserveHost: true</span><br><span class="line"></span><br><span class="line"># Kibana uses an index in Elasticsearch to store saved searches, visualizations</span><br><span class="line"># and dashboards. It will create a new index if it doesn&apos;t already exist.</span><br><span class="line">kibana.index: &quot;.kibana&quot; # kibana</span><br><span class="line"></span><br><span class="line"># The default application to load.</span><br><span class="line"># kibana.defaultAppId: &quot;discover&quot;</span><br><span class="line"></span><br><span class="line"># If your Elasticsearch is protected with basic auth, these are the user credentials</span><br><span class="line"># used by the Kibana server to perform maintenance on the kibana_index at startup. Your Kibana</span><br></pre></td></tr></table></figure><p>配置比较简单<br>配置完成后开始运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost kibana-4.6.1-linux-x86]# ./bin/kibana</span><br><span class="line">log   [02:48:34.732] [info][status][plugin:kibana@1.0.0] Status changed from uninitialized to green - Ready</span><br><span class="line">log   [02:48:34.771] [info][status][plugin:elasticsearch@1.0.0] Status changed from uninitialized to yellow - Waiting for Elasticsearch</span><br><span class="line">log   [02:48:34.803] [info][status][plugin:kbn_vislib_vis_types@1.0.0] Status changed from uninitialized to green - Ready</span><br><span class="line">log   [02:48:34.823] [info][status][plugin:markdown_vis@1.0.0] Status changed from uninitialized to green - Ready</span><br><span class="line">log   [02:48:34.827] [info][status][plugin:metric_vis@1.0.0] Status changed from uninitialized to green - Ready</span><br><span class="line">log   [02:48:34.835] [info][status][plugin:elasticsearch@1.0.0] Status changed from yellow to green - Kibana index ready</span><br><span class="line">log   [02:48:34.840] [info][status][plugin:spyModes@1.0.0] Status changed from uninitialized to green - Ready</span><br><span class="line">log   [02:48:34.847] [info][status][plugin:statusPage@1.0.0] Status changed from uninitialized to green - Ready</span><br><span class="line">log   [02:48:34.857] [info][status][plugin:table_vis@1.0.0] Status changed from uninitialized to green - Ready</span><br><span class="line">log   [02:48:34.867] [info][listening] Server running at http://192.168.30.128:5601</span><br></pre></td></tr></table></figure><p>在浏览器运行  <a href="http://192.168.30.128:5601" target="_blank" rel="noopener">http://192.168.30.128:5601</a></p><p><img src="http://img.blog.csdn.net/20160922113810546" alt="这里写图片描述"></p><p>这里要先添加 index，在 输入框输入我们刚刚收集的 apachelog 作为 index 名称</p><p><img src="http://img.blog.csdn.net/20160922113836334" alt="这里写图片描述"></p><p>点击 create 创建</p><p><img src="http://img.blog.csdn.net/20160922113919343" alt="这里写图片描述"></p><p>右上角选择时间来显示我们的数据访问，下面是数据的访问量</p><p>中间的搜索框可输入搜索条件搜索，搜索完成后点击右上角的 save seach 保存搜索数据 </p><p><img src="http://img.blog.csdn.net/20160922113936492" alt="这里写图片描述"></p><p>点击 visualize 可以画出其他的数据分析图，比如饼状图</p><p><img src="http://img.blog.csdn.net/20160922114217980" alt="这里写图片描述"></p><p>选择我们刚刚保存的 chrome 的文件来生成饼状图</p><p>因为数据没什么变化，所以只能全部是一样的。还是点击右上角的保存按钮，将饼状图保存为 test</p><p><img src="http://img.blog.csdn.net/20160922114030368" alt="这里写图片描述"></p><p>添加到 面板中，点击 dashboard<br>点击 + 号添加</p><p><img src="http://img.blog.csdn.net/20160922114055328" alt="这里写图片描述"></p><p>选择 test 来显示到面板，效果如下</p><p><img src="http://img.blog.csdn.net/20160922114123360" alt="这里写图片描述"></p><p>这样简单的 ELK 系统就搭建起来了，当然，正真的使用环境中，我们会使用集群搭建。利用 redis 来处理日志队列。</p><h2 id="marvel-插件"><a href="#marvel-插件" class="headerlink" title="marvel 插件"></a>marvel 插件</h2><p>Marvel是Elasticsearch的管理和监控工具，在开发环境下免费使用。拥有更好的数据图表界面。</p><p>首先在 elastaticsearch 下安装 marvel-agent 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[elsearch@localhost elasticsearch-2.4.0]$ ./bin/plugin install license</span><br><span class="line">[elsearch@localhost elasticsearch-2.4.0]$ ./plugin install marvel-agent</span><br></pre></td></tr></table></figure><p>这里注意，必须先执行 license 安装，再执行 marvel-agent 安装，安装完成后重启  elastaticseach<br>接下来 kibana 来安装 marvel 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost kibana-4.6.1-linux-x86]# cd bin</span><br><span class="line">[root@localhost bin]# ./kibana plugin --install elasticsearch/marvel/latest</span><br></pre></td></tr></table></figure><p>安装完成后重启 kibana，选择 marvel 插件</p><p><img src="http://img.blog.csdn.net/20160922114438389" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160922114331767" alt="这里写图片描述"></p><p>是不是感觉有点高大上。。。</p><p>好了 ELK 的基本搭建就算是完成了，接下来我们考虑如何集群来使用这个系统。</p><p>欢迎指正， Thanks….</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> LogStash </tag>
            
            <tag> Kibana </tag>
            
            <tag> Marvel </tag>
            
            <tag> Log </tag>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>点直播流媒体传输协议之 —— HLS（HTTP Live Streaming）</title>
      <link href="/2016/09/13/hls/"/>
      <url>/2016/09/13/hls/</url>
      <content type="html"><![CDATA[<hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在最近一年的工作中接触比较多的是视频点播和直播，也了解到了一些点直播的后端技术，这段时间希望将了解到的一些技术总结下来，这篇文章主要介绍流媒体协议 HLS</p><a id="more"></a><h2 id="流媒体协议"><a href="#流媒体协议" class="headerlink" title="流媒体协议"></a>流媒体协议</h2><p>常用的流媒体协议主要有 HTTP 渐进下载和基于 RTSP/RTP 的实时流媒体协议，这两种协议是完全不同的实现方式。主要区别如下：</p><ol><li>一种是分段渐近下载，一种是基于实时流来实现播放</li><li>协议不同，HTTP 协议的渐近下载意味着你可以在一台普通的 HTTP 的应用服务器上就可以直接提供点播和直播服务</li><li>延迟有差异，HTTP 渐近下载的方式的延迟理论上会略高于实时流媒体协议的播放</li><li>渐近下载会生成索引文件，所以需要考虑存储，对 I/O 要求较高</li></ol><h2 id="HLS简介"><a href="#HLS简介" class="headerlink" title="HLS简介"></a>HLS简介</h2><p>HLS （HTTP Live Streaming）是苹果公司实现的基于 HTTP 的流媒体协议，可以实现流媒体的点播和直播播放。当然，起初是只支持苹果的设备，目前大多数的移动设备也都实现了该功能。HTML5 直接支持该协议。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>HLS 点播是常见的分段 HTTP 点播，就是将视频流分成不同的片段，客户端不断的去下载该片段，由于片段之间的分段间隔时间非常短，所以看起来是一条完整的播放流，实现的重点是对于媒体文件的分割。同时，HLS 还支持多码率的切换，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。多清晰度就是这样实现的。<br>为了播放媒体流，客户端首先需要获得播放列表文件，也就是根据 HLS 生成的片段列表，该列表中包含每个流媒体的文件，客户端以类似轮询的方式不断重复加载播放列表文件并将片段追加实现流媒体的播放。<br>播放列表文件就是通常我们所说的 m3u8 文件，是以后缀 .m3u8 Content-Type是”application/vnd.apple.mpegurl” 的文件。</p><h2 id="m3u8-介绍与分析"><a href="#m3u8-介绍与分析" class="headerlink" title="m3u8 介绍与分析"></a>m3u8 介绍与分析</h2><p>m3u8 文件本质说其实是采用了编码是 UTF-8 的 m3u 文件。<br>它只是一个纯索引文件，一个文件片段的列表，客户单打开它并不是播放它，而是根据它里面的文件片段找到视频文件的网路地址进行播放</p><p>这里抓包抓了一个 m3u8 文件打开看一下究竟是什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VIDEO-INF:VIDEO=559ac1317682fa1fcdc67ed2774e4e1a980e0c264cefceb5c.....</span><br><span class="line">#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=245760</span><br><span class="line">https://*******.com/video/cif/hNAQ0_jbip4j-0o_BhcdqMwyQxwtwbo1k3vVZhtjbcQ.m3u8</span><br><span class="line">#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=491520</span><br><span class="line">https://******.com/video/sd/hNAQ0_jbip4j-0o_BhcdqMwyQxwtwbo1k3vVZhtjbcQ.m3u8</span><br></pre></td></tr></table></figure><p>分析该 m3u8 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U：扩展标记 ，意思是我是 m3u 文件</span><br><span class="line">#EXT-X-VIDEO-INF:VIDEO ：这个应该是自己定义的一个标签，指名是视频文件，后面可能跟的是视频标题之类的</span><br><span class="line">#EXT-X-STREAM-INF</span><br><span class="line">指定一个包含多媒体信息的 media URI 作为PlayList，一般做M3U8的嵌套使用，它只对紧跟后面的URI有效，#EXT-X-STREAM-INF:有以下属性：</span><br><span class="line">BANDWIDTH：带宽，491520</span><br><span class="line">PROGRAM-ID：该值是一个十进制整数，惟一地标识一个在PlayList文件范围内的特定的描述。一个PlayList 文件中可能包含多个有相同ID的此tag。</span><br><span class="line">CODECS：不是必须的。</span><br><span class="line">RESOLUTION：分辨率。</span><br><span class="line">AUDIO：这个值必须和AUDIO类别的“EXT-X-MEDIA”标签中“GROUP-ID”属性值相匹配。</span><br></pre></td></tr></table></figure></p><p>这里 PlayList 的地址我们发现还是个 m3u8 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://*******.com/video/cif/hNAQ0_jbip4j-0o_BhcdqMwyQxwtwbo1k3vVZhtjbcQ.m3u8</span><br><span class="line">https://******.com/video/sd/hNAQ0_jbip4j-0o_BhcdqMwyQxwtwbo1k3vVZhtjbcQ.m3u8</span><br></pre></td></tr></table></figure><p>可以观察发现，这其实是 cif 和 sd 两种不同清晰度的 m3u8 文件，客户端根据网络或者选项去选择不同的清晰度的 m3u8 文件。<br>上面的 m3u8 文件为一级 m3u8 文件，这两个 m3u8 就称为二级 m3u8 文件，那么我们就顺着二级 m3u8 文件继续查看，将其中一个下载到本地打开分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VERSION:3</span><br><span class="line">#EXT-X-TARGETDURATION:11</span><br><span class="line">#EXTINF:12.400,</span><br><span class="line">http://*************/**/M00/00/BB/Cn1GQlfWRFaACQaQAAvsEEMIWI42131.ts</span><br><span class="line">#EXTINF:10.000,</span><br><span class="line">http://*************/**/M00/00/BB/Cn1GQlfWRFaAJO1mAAaTMDz8P4E9292.ts</span><br><span class="line">#EXTINF:10.000,</span><br><span class="line">http://*************/**/M00/00/BB/Cn1GQlfWRFaAZ2fyAAVQEM22iWA2544.ts</span><br><span class="line">#EXTINF:11.120,</span><br><span class="line">http://*************/**/M00/00/BB/Cn1GQlfWRFaAIfwHAAirSMgfpx03176.ts</span><br><span class="line">#EXTINF:17.240,</span><br><span class="line">http://*************/**/M00/00/BB/Cn1GQlfWRFaAaiz6AAn0SHY1csA7539.ts</span><br><span class="line">#EXTINF:3.720,</span><br><span class="line">http://*************/**/M00/00/BB/Cn1GQlfWRFaARLJ2AAGYUIIpGKA7707.ts</span><br><span class="line">#EXT-X-ENDLIST</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#EXT-X-VERSION:3 : 版本</span><br><span class="line">#EXT-X-TARGETDURATION: 11</span><br><span class="line">指定最大的媒体段时间长（秒）。所以#EXTINF中指定的时间长度必须小于或是等于这个最大值。这个tag在整个PlayList文件中只能出现一 次（在嵌套的情况下，一般有真正ts url     的m3u8才会出现该tag）</span><br><span class="line">#EXTINF: duration 指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效，title是下载资源的url</span><br><span class="line">#EXT-X-ENDLIST 结束列表</span><br></pre></td></tr></table></figure><p>这里我们看到了真正播放的流片段，ts 片，客户端拿到的就是这个 ts 片，然后不断下载请求到该片段并连续播放。</p><p>有些人可能要问了，那 ts 文件又到底是个什么东西呢，那就下载来看看，拿着其中的一个 ts 文件浏览器打开保存到本地：</p><p><img src="http://img.blog.csdn.net/20160913114717400" alt="这里写图片描述"></p><p>发现保存到本地的文件就可以直接打开，其实就是真正的流媒体文件，但是这个文件只是片段，大概只有 10s 的时间。</p><h2 id="HLS播放实现时序图"><a href="#HLS播放实现时序图" class="headerlink" title="HLS播放实现时序图"></a>HLS播放实现时序图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title:流媒体播放实现时序图</span><br><span class="line">客户端-&gt;服务端play接口:请求</span><br><span class="line">服务端play接口-&gt;客户端:返回一级 m3u8地址</span><br><span class="line">客户端-&gt;m3u8文件服务器:获取一级m3u8文件</span><br><span class="line">客户端-&gt;m3u8文件服务器:获取二级m3u8文件</span><br><span class="line">客户端-&gt;ts文件服务器:不断获取 ts 流媒体文件</span><br></pre></td></tr></table></figure><h2 id="HLS-直播"><a href="#HLS-直播" class="headerlink" title="HLS 直播"></a>HLS 直播</h2><p>HLS 直播原理上还是按点播的方式实现的，通过 http 协议传输，生成 ts 索引文件以及 m3u8 索引文件。直播的复杂在于先要采集视频源和音频源的数据，然后再进行 H264 编码和音频 ACC 编码，并封装成 ts 包，其中还要考虑 ts 的分段生成策略。</p><p>下一篇我会介绍一篇关于 rtmp 协议的文章。</p><p>欢迎指正，Thanks…</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HLS </tag>
            
            <tag> TS </tag>
            
            <tag> M3U8 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>You-get 的安装与使用</title>
      <link href="/2016/09/12/you-get-install/"/>
      <url>/2016/09/12/you-get-install/</url>
      <content type="html"><![CDATA[<hr><h2 id="You-get-介绍"><a href="#You-get-介绍" class="headerlink" title="You-get 介绍"></a>You-get 介绍</h2><p>You-Get 是一款命令行工具，用来下载网页中的视频、音频、图片，支持众多网站，包含 41 家国内主流视频、音乐网站，如 网易云音乐、AB 站、百度贴吧、斗鱼、熊猫、爱奇艺、凤凰视频、酷狗音乐、乐视、荔枝FM、秒拍、腾讯视频、优酷土豆、央视网、芒果TV 等等，只需一个命令就能直接下载视频、音频以及图片回来，并且可以自动合并视频。而对于有弹幕的网站，比如 B 站，还可以将弹幕下载回来。本篇文章介绍  you-get 的安装</p><a id="more"></a><h2 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h2><p>官网地址：<a href="https://you-get.org/" target="_blank" rel="noopener">https://you-get.org/</a><br>github地址：<a href="https://github.com/soimort/you-get/" target="_blank" rel="noopener">https://github.com/soimort/you-get/</a><br>中文说明：<br><a href="https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E</a><br>安装准备： python3<br>安装方法：</p><ol><li>安装 pip3</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip #安装 you-get</span><br><span class="line">sudo pip3 install you-get</span><br></pre></td></tr></table></figure><ol start="2"><li>下载安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://github.com/soimort/you-get/releases/download/v0.4.523/you-get-0.4.523.tar.gz</span><br><span class="line">sudo tar -zxvf you-get-0.4.523.tar.gz</span><br><span class="line">cd you-get</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>更新方法:</p><ol><li>pip3 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade you-get</span><br></pre></td></tr></table></figure><ol start="2"><li>普通更新</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get https://github.com/soimort/you-get/archive/master.zip</span><br></pre></td></tr></table></figure><h2 id="Windows-安装"><a href="#Windows-安装" class="headerlink" title="Windows 安装"></a>Windows 安装</h2><ol><li>安装 Python3 </li></ol><p>安装比较简单，这里不再说明</p><ol start="2"><li>安装 pip</li></ol><p>下载地址:<a href="https://pypi.python.org/pypi/pip#downloads" target="_blank" rel="noopener">https://pypi.python.org/pypi/pip#downloads</a><br>选择 pip-8.1.2.tar.gz (md5, pgp) 下载<br>解压到一个目录下，打开 CMD 命令行，进入该目录<br>执行: python3 setup.py install<br>自动安装</p><p>安装完成后，注意一下 pip 安装的路径</p><p><img src="http://img.blog.csdn.net/20160912160449553" alt="这里写图片描述"></p><p>我这里的路径是 D:\Program Files(86)\python3\Scripts<br>将pip 的安装路径添加到环境变量中 path</p><ol start="3"><li>安装 you-get</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install you-get</span><br></pre></td></tr></table></figure><p>OK ,Windows 下的 you-get 安装成功.</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> You-get </tag>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sphinx 在网站应用中的服务架构设计</title>
      <link href="/2016/09/06/sphinx-web/"/>
      <url>/2016/09/06/sphinx-web/</url>
      <content type="html"><![CDATA[<hr><h2 id="Sphinx-简单介绍"><a href="#Sphinx-简单介绍" class="headerlink" title="Sphinx 简单介绍"></a>Sphinx 简单介绍</h2><ol><li><p>介绍<br>Sphinx 是一个基于 SQL 的全文检索引擎，可以给 Mysql、PostgreSQL 做检索，提供比数据库更加专业的搜索功能。Sphinx 的搜索API接口支持 PHP,Python,Ruby,等。Sphinx 单一索引最大可包含1亿条记录，在1千万条记录情况下的查询速度为0.x秒（毫秒级）。Sphinx创建索引的速度为：创建100万条记录的索引只需 3～4分钟，创建1000万条记录的索引可以在50分钟内完成，而只包含最新10万条记录的增量索引，重建一次只需几十秒</p></li><li><p>主要特性</p></li></ol><ul><li>高速索引</li><li>高速搜索</li><li>支持分布式搜索</li><li>提供从Mysql 内部的插件式存储引擎上搜索</li><li>采用 UTF-8 字符集</li><li>支持 Windows/Linux/MacOX</li></ul><ol start="3"><li>使用场景<br>如果数据库的数据量不是很多，百万级的数据，可以采用数据库索引来进行检索，但是对于上千万的数据量的话就用数据库直接检索的效率就会有所下降，特别对于采用分库分表的数据库设计，如果要检索非主键的字段的话，将会非常麻烦。<br>比如用户表 user，用户量大的时候，我们一般会采用分表的方式来提高应用的访问性能。user_0 ~ user_63 ,总共 64 张表,user_id 作为 主键<br>表结构如下。<br>user_id    name    password    age<br>int    char(100)    char(32)    int<br>如果知道 user_id = 65，那我们很容易找到用户的信息, 65 % 64 = 1，那就在 user_1 表中，采用 select <em> from user_1 ….<br>但是如果我想检索名字叫 “phachon” 的用户，这个就比较麻烦了，最笨的办法就是每一张表都去查找 select </em>  from user_* where name LIKE %phchon% ,这样要循环 64 次，再将数据合并起来，这样显然是不可行的，数据库的开销太大，造成应用程序的性能下降。</li></ol><p>Sphinx 就可以帮我们解决上面所说的问题。当然，Sphinx 可以应用的场景很多，上面只是其中的一种。</p><a id="more"></a><h2 id="Sphinx-在网站应用程序中的应用架构设计"><a href="#Sphinx-在网站应用程序中的应用架构设计" class="headerlink" title="Sphinx 在网站应用程序中的应用架构设计"></a>Sphinx 在网站应用程序中的应用架构设计</h2><p>以下是最近在工作中使用 Sphinx 来进行后台数据检索的应用架构设计</p><p><img src="http://img.blog.csdn.net/20160906161425934" alt="这里写图片描述"></p><p>web application 应用程序层 select 操作只用请求 Server Api 层的 select 接口；update/insert/delete 操作先操作数据库再请求 Server Api 的 update 更新接口。<br>Server Api 层通过 Nginx + php 连接 Sphinx 客户端，主要提供了两个接口 select 查询接口和 update 更新接口。select 接口需要查询全量（main）索引和增量（delta）做索引的数据，取其数据的交集才是真正需要的数据。<br>Sphinx 客户端建了两个索引，全量索引（main）和增量索引（delta），每天凌晨 1 点通过脚本进行定时任务重建索引，如果插入或者修改量很低的话，重建索引的频率可适当调整。应用层更新操作可通过消息队列来异步实现。<br>DB 数据库层读库和写库及时同步保证数据的一致性。</p><p>Server Api 层连接 Sphinx 客户端的可使用 SphinxClinet 类或者 foolz/sphinxql-query-builder 类来实现。</p><h2 id="Sphinx-配置"><a href="#Sphinx-配置" class="headerlink" title="Sphinx 配置"></a>Sphinx 配置</h2><p>Sphinx 在 Linux 下的安装可参考之前写的一篇文章<a href="./sphinx-install.md">《Sphinx 在Linux下的安装与基本配置》</a></p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Mysql </tag>
            
            <tag> Sphinx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sphinx 在 Linux 下的安装与基本配置</title>
      <link href="/2016/09/06/sphinx-install/"/>
      <url>/2016/09/06/sphinx-install/</url>
      <content type="html"><![CDATA[<hr><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>Sphinx 官网：<a href="http://sphinxsearch.com/" target="_blank" rel="noopener">http://sphinxsearch.com/</a><br>wget <a href="http://sphinxsearch.com/files/sphinx-2.2.10-release.tar.gz" target="_blank" rel="noopener">http://sphinxsearch.com/files/sphinx-2.2.10-release.tar.gz</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf sphinx-2.2.10-release.tar.gz</span><br><span class="line">cd sphinx-2.2.10-release</span><br></pre></td></tr></table></figure><p>找到 mysql 的安装目录，我的是在 /usr/bin/mysql 执行 /usr/lcoal/sphinx 为 sphinx 的安装目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --prefix=/usr/local/sphinx --with-mysql=/usr/local/mysql</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>不出问题的话应该已经安装成功了</p><a id="more"></a><p>其他参数的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--with-mysql-includes=/usr/local/mysql/include/mysql/</span><br><span class="line">--with-mysql-libs=/usr/local/mysql/lib/mysql/</span><br><span class="line">--with-mmseg=/usr/local/mmseg/</span><br><span class="line">--with-mmseg-includes=/usr/local/mmseg/include/mmseg/</span><br><span class="line">--with-mmseg-libs=/usr/local/mmseg/lib/</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>找到 sphinx 的安装目录 /usr/local/sphinx/etc .复制一份 sphinx.conf.dist 为 test.conf<br>打开文件对照注释编写配置文件。由于都是英文，这里将经常用到的一些配置做解释如下：</p><p>数据源配置解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">source </span><br><span class="line">&#123;</span><br><span class="line"> # 数据源类型 mysql，pgsql，mssql，xmlpipe，xmlpipe2，odbc</span><br><span class="line"> type= mysql</span><br><span class="line"> # -------------------------连接sql数据源的一些配置---------------------------</span><br><span class="line"> sql_host        = localhost</span><br><span class="line"> sql_user        = root</span><br><span class="line"> sql_pass       = 123456</span><br><span class="line"> sql_db           = test</span><br><span class="line"> sql_port         = 3306</span><br><span class="line"> #  使用 unix sock连接可以使用这个</span><br><span class="line"> #sql_sock      = /tmp/mysql.sock</span><br><span class="line"></span><br><span class="line"> # --------------------------mysql 相关配置----------------------------------------</span><br><span class="line"></span><br><span class="line"> # mysql 与 sphinx 之间的交互，0/32/2048/32768  无/使用压缩协议/握手后切换到ssl/Mysql 4.1版本身份认证。</span><br><span class="line"> mysql_connect_flags   = 32</span><br><span class="line"> ## 当mysql_connect_flags设置为2048（ssl）的时候，下面几个就代表ssl连接所需要使用的几个参数。</span><br><span class="line"> # mysql_ssl_cert        = /etc/ssl/client-cert.pem</span><br><span class="line"> # mysql_ssl_key     = /etc/ssl/client-key.pem</span><br><span class="line"> # mysql_ssl_ca      = /etc/ssl/cacert.pem</span><br><span class="line"></span><br><span class="line"> #---------------------------mssql 相关配置----------------------------------------</span><br><span class="line"> # 是否使用 windows 登陆</span><br><span class="line"> # mssql_winauth     = 1</span><br><span class="line"> # 使用unicode还是单字节数据</span><br><span class="line"> # mssql_unicode     = 1</span><br><span class="line"> </span><br><span class="line"> #----------------------------odbc 相关配置-------------------------------------------</span><br><span class="line"> odbc_dsn      = DBQ=C:\data;DefaultDir=C:\data;Driver=&#123;Microsoft Text Driver (*.txt; *.csv)&#125;;</span><br><span class="line"></span><br><span class="line"> #-----------------------------sql 相关配置--------------------------------------------</span><br><span class="line"> # sql某一列的缓冲大小，一般是针对字符串来说的</span><br><span class="line"> # sql_column_buffers    = content=12M, comments=1M</span><br><span class="line"> # 索引的 sql 执行前需要执行的操作，比如设置字符串为 utf8</span><br><span class="line"> sql_query_pre     = SET NAMES utf8</span><br><span class="line"> # 索引的 sql 执行语句</span><br><span class="line"> sql_query       =  SELECT id, name, age FROM test</span><br><span class="line"> # 联合查询</span><br><span class="line"> # sql_joined_field是增加一个字段，这个字段是从其他表查询中查询出来的。</span><br><span class="line"> # 如果是query，则返回id和查询字段，如果是payload-query，则返回id，查询字段和权重</span><br><span class="line"> # 查询需要按照id进行升序排列</span><br><span class="line"> # sql_joined_field  = tags from query; SELECT docid, CONCAT(&apos;tag&apos;,tagid) FROM tags ORDER BY docid ASC</span><br><span class="line"> # sql_joined_field  = wtags from payload-query; SELECT docid, tag, tagweight FROM tags ORDER BY docid ASC</span><br><span class="line"></span><br><span class="line"> #----------------------------字段属性的配置（用于过滤和排序）----------------------------------------</span><br><span class="line"> # uint无符号整型属性</span><br><span class="line"> sql_attr_uint       = id</span><br><span class="line"> # 布尔值属性</span><br><span class="line"> # sql_attr_bool     = is_deleted</span><br><span class="line"> # 长整型属性(有负数用 bigint)</span><br><span class="line"> # sql_attr_bigint       = my_bigint_id</span><br><span class="line"> # 时间戳属性，经常被用于做排序</span><br><span class="line"> sql_attr_timestamp  = date_added</span><br><span class="line"> # 字符串排序属性。一般我们按照字符串排序的话，我们会将这个字符串存下来进入到索引中，然后在查询的时候比较索引中得字符大小进行排序。</span><br><span class="line"> # 但是这个时候索引就会很大，于是我们就想到了一个方法，我们在建立索引的时候，先将字符串值从数据库中取出，暂存，排序。</span><br><span class="line"> # 然后给排序后的数组分配一个序号，然后在建立索引的时候，就将这个序号存入到索引中去。这样在查询的时候也就能完成字符串排序的操作。</span><br><span class="line"> # 这，就是这个字段的意义。</span><br><span class="line"> # sql_attr_str2ordinal  = author_name</span><br><span class="line"> # 浮点数属性</span><br><span class="line"> # sql_attr_float        = lat_radians</span><br><span class="line"> # sql_attr_float        = long_radians</span><br><span class="line"> # 字符串属性</span><br><span class="line"> # sql_attr_string       = stitle</span><br><span class="line"> # 文档词汇数记录属性。比如下面就是在索引建立的时候增加一个词汇数的字段</span><br><span class="line"> # sql_attr_str2wordcount    = stitle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> # sphinx 的 source 有继承属性，也就是说共有的部分可以写在父级数据源中，比如数据库连接配置信息</span><br><span class="line"> source main_0: main</span><br><span class="line">&#123;</span><br><span class="line">   sql_ranged_throttle = 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引配置解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">index test1</span><br><span class="line">&#123;</span><br><span class="line">   # 索引类型，包括有plain，distributed和rt。分别是普通索引/分布式索引/增量索引。默认是plain。</span><br><span class="line">   # type          = plain</span><br><span class="line">   # 索引数据源</span><br><span class="line">   source          = src1</span><br><span class="line">   # 索引文件存放路径</span><br><span class="line">   path            =/usr/local/sphinx/var/data/src1</span><br><span class="line">   # 字符集编码类型，可以为sbcs,utf-8</span><br><span class="line">   charset_type        =  utf-8</span><br><span class="line">   # 字符表和大小写转换规则</span><br><span class="line">   # &apos;sbcs&apos; default value is</span><br><span class="line">   # charset_table     = 0..9, A..Z-&gt;a..z, _, a..z, U+A8-&gt;U+B8, U+B8, U+C0..U+DF-&gt;U+E0..U+FF, U+E0..U+FF</span><br><span class="line">   # &apos;utf-8&apos; default value is</span><br><span class="line">   # charset_table     = 0..9, A..Z-&gt;a..z, _, a..z, U+410..U+42F-&gt;U+430..U+44F, U+430..U+44F</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索服务searchd 配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">searchd</span><br><span class="line">&#123;</span><br><span class="line">   # 监听端口</span><br><span class="line">   listen          = 9312</span><br><span class="line">   listen          = 9307:mysql4</span><br><span class="line">   # 监听日志路径</span><br><span class="line">   log             = /usr/local/sphinx/var/log/searchd.log</span><br><span class="line">   # 查询日志路径</span><br><span class="line">   query_log       = /usr/local/sphinx/var/log/query.log</span><br><span class="line">   # 客户端读超时时间</span><br><span class="line">   read_timeout    = 5</span><br><span class="line">   # 客户端持久时间</span><br><span class="line">   client_timeout  = 300</span><br><span class="line">   #并行执行搜索数量</span><br><span class="line">   max_children    = 0</span><br><span class="line">   #进程 pid 文件</span><br><span class="line">   pid_file        = /usr/local/sphinx/var/log/searchd.pid</span><br><span class="line">   #当进行索引轮换的时候，可能需要消耗大量的时间在轮换索引上。</span><br><span class="line">   # 启动了无缝轮转，就以消耗内存为代价减少轮转的时间</span><br><span class="line">   seamless_rotate = 1</span><br><span class="line">   # 索引预开启，强制重新打开所有索引文件</span><br><span class="line">   preopen_indexes = 1</span><br><span class="line">   # 索引轮换成功之后，是否删除以.old为扩展名的索引拷贝</span><br><span class="line">   unlink_old      = 1</span><br><span class="line">   # 多值属性MVA更新的存储空间的内存共享池大小</span><br><span class="line">   mva_updates_pool = 1M</span><br><span class="line">   #网络通讯时允许的最大的包的大小</span><br><span class="line">   max_packet_size = 8M</span><br><span class="line">   # 每次查询允许设置的过滤器的最大个数</span><br><span class="line">   max_filters     = 256</span><br><span class="line">   # 单个过滤器允许的值的最大个数</span><br><span class="line">   max_filter_values = 4096</span><br><span class="line">   # 每次批量查询的查询数限制</span><br><span class="line">   max_batch_queries = 32</span><br><span class="line">   # 多处理模式（MPM）。 可选项；可用值为none、fork、prefork，以及threads。 默认在Unix类系统为form，Windows系统为threads。</span><br><span class="line">   workers         = form</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开启sphinx"><a href="#开启sphinx" class="headerlink" title="开启sphinx"></a>开启sphinx</h2><h3 id="生成索引"><a href="#生成索引" class="headerlink" title="生成索引"></a>生成索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/sphinx/bin/indexer --config /usr/local/sphinx/etc/test.conf --all</span><br></pre></td></tr></table></figure><h3 id="打开-sphinx-进程"><a href="#打开-sphinx-进程" class="headerlink" title="打开 sphinx 进程"></a>打开 sphinx 进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/sphinx/bin/searchd --config /usr/local/sphinx/etc/sphinx.conf</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.cnblogs.com/yjf512/p/3598332.html" target="_blank" rel="noopener">http://www.cnblogs.com/yjf512/p/3598332.html</a></li></ol>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Mysql </tag>
            
            <tag> Sphinx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IO 模型简介</title>
      <link href="/2016/09/05/io/"/>
      <url>/2016/09/05/io/</url>
      <content type="html"><![CDATA[<hr><p>最近工作中接触到关于网络编程的一些东西，发现对于网络、IO编程、socket、进程、线程、协程、TCP/IP等基本知识理解不够深入。所以需要从头到尾总结一下。</p><a id="more"></a><h2 id="什么是-IO"><a href="#什么是-IO" class="headerlink" title="什么是 IO"></a>什么是 IO</h2><p>IO 的英文来源是 Input/Output，即输入/输出，我们的程序和数据在运行过程中会在内存中驻留，由 CPU 来计算，涉及到数据交换的地方，就需要IO接口，IO 包括网络 IO, 内存 IO,磁盘IO等。</p><p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。（摘自<a href="http://www.liaoxuefeng.com/）" target="_blank" rel="noopener">http://www.liaoxuefeng.com/）</a></p><p>IO 模型大概分为</p><ul><li>阻塞 IO（blocking IO）</li><li>非阻塞 IO（non-blocking IO）</li><li>IO 复用（IO multiplexing）</li><li>异步 IO（asynchronous IO）</li><li>同步 IO（synchronous IO）</li></ul><p>但是这几种 IO 模型到底是什么，又分别有什么区别。这里我搜索了一些资料并融入自己的理解详细解释一下。</p><h2 id="阻塞-IO（blocking-IO）"><a href="#阻塞-IO（blocking-IO）" class="headerlink" title="阻塞 IO（blocking IO）"></a>阻塞 IO（blocking IO）</h2><p>这里先从阻塞 IO 说起，因为 Linux 中默认的网路模型基本都是阻塞 IO。根据调用关系粗略画的时序图如下：</p><p><img src="http://img.blog.csdn.net/20160905170247472" alt="这里写图片描述"></p><p>当用户进程调用 recvform 这个系统调用，linux 内核 kernel 开始工作：准备接受数据， 数据一开始往往还没有到达，（例如，网络IO还没有接受到一个完整的 UDP包），这个时候 kernel 需要等待一段时间来接受完数据。在这个过程中，用户进程就会什么也做不了，只能等 kernel 接受完数据并拷贝数据到用户内存中，然后返回消息给用户进程，进程才能继续操作。对于用户进程来说，等待 kernel 返回数据的过程就叫阻塞（block）。等数据返回才能解除阻塞。<br>所以，阻塞 IO 模型的特点就是在 IO 执行的输入和输出，都被阻塞掉了。</p><p>打个比喻：去餐厅吃饭，点餐完，你在柜台一直等饭，柜台接受到你的订单开始准备做饭，这时候你只能一直等哪里也不能去，就像是被阻塞，等饭出来了，你拿着饭才走。解除阻塞。</p><h2 id="非阻塞-IO-non-blocking-IO"><a href="#非阻塞-IO-non-blocking-IO" class="headerlink" title="非阻塞 IO non-blocking IO"></a>非阻塞 IO non-blocking IO</h2><p>了解了阻塞 IO，我们来看看非阻塞IO模型的具体流程。还是以用户进程的一次调用为例，调用时序图大致如下：</p><p><img src="http://img.blog.csdn.net/20160905170419441" alt="这里写图片描述"></p><p>当用户进程调用系统调用，kernel 内核开始准备接受数据，如果一开始没有接受到数据，会立刻返回 error 给用户进程，用户进程就知道数据还没有准备好，就会再次发送调用，直到数据准备好，然后立刻会将数据拷贝到内存中，并返回信息给用户进程，在这个过程中用户进程并不需要等待，每次调用开始到结束的过程，如果出错，kernel 都会立刻返回 error 消息给它。这种模型被称为非阻塞 IO 模型。<br>非阻塞IO 模型的特点是不需要等待，但是需要用户进程不断的去调用。</p><p>需要注意的是， 在我的理解下，在系统调用时，如果没有准备好数据就立刻返回给进程 error 信息，这个过程确实是非阻塞的，但是，当数据准备好之后，kernel 开始将数据拷贝到内存中的这段时间内，用户进程其实还是阻塞的。</p><p>又打个比喻：还是上面说的去餐馆吃饭，当在柜台点完餐，这个时候服务员说现在做饭需要的食材还没有准备好，你知道了这个信息后，隔一会就去重新点一次餐，最终服务员说食材准备好了，并做好了饭给你。在做饭的过程中可能会不断遇到各种问题不能下单，你只能去不断的重新点餐。</p><h2 id="IO-复用"><a href="#IO-复用" class="headerlink" title="IO 复用"></a>IO 复用</h2><p>非阻塞模型中存在的问题是用户进程需要不断去调用内核，IO 复用模型的出现就是来解决这个问题的，IO 复用模型是建立在内核提供的多路分离函数 select 函数之上的，一个 select 中可以同时处理多个 socket 请求。所以用户一次调用可以注册多个 socket 请求。时序图大致如下：</p><p><img src="http://img.blog.csdn.net/20160905170437112" alt="这里写图片描述"></p><p>用户进程使用select 函数注册多个 socket 请求，这时候整个进程就会被阻塞，kernel会“监视”所有select负责的socket，只要其中的一个 socket 请求的数据准备成功，select 就会返回给用户进程可读的消息，这个时候用户进程再调用 read 操作去讲数据拷贝到 内存中。在这个模型中，我们一般设置 select 中的每个 socket 为非阻塞的，但是其实整个进程是被 select 阻塞的。<br>IO 复用的特点是需要两次系统调用（system），并且需要调用 select ，可以同时处理多个 socket 连接。<br>如果处理的连接数不是很高的话，使用select/epoll的 web server 不一定比使用 multi-threading + blocking IO 的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p><h2 id="异步IO（asynchronous-IO）"><a href="#异步IO（asynchronous-IO）" class="headerlink" title="异步IO（asynchronous IO）"></a>异步IO（asynchronous IO）</h2><p>异步IO模型中，当用户发起请求之后，就会立刻得到返回，并去做其他事情去了，从 kernel 角度来讲，他在接受到请求会立刻返回给用户进程消息，不会对其造成任何的阻塞，然后 kernel 会自己等待数据接受完毕并将数据拷贝到内存中，当这一切都完成后 kernel 会发送一个消息给用户进程，告诉它已经操作完成。时序图如下:</p><p><img src="http://img.blog.csdn.net/20160905170453144" alt="这里写图片描述"></p><p>相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。</p><h2 id="同步IO"><a href="#同步IO" class="headerlink" title="同步IO"></a>同步IO</h2><p>同步IO 的概念是：一个同步 IO 的操作会导致请求的进程被阻塞，直到整个进程完成。<br>有的人可能要说了，阻塞IO 和 IO 多路复用是同步 IO, 非阻塞IO 就是同步 IO。我的理解不是这样的，阻塞IO 和多路复用 IO 肯定是同步 IO，但非阻塞IO 其实本质上也是同步 IO。<br>在非阻塞IO 那里，最后写了需要注意的一个问题，就是当数据准备好之后，kernel 拷贝数据到内存的过程中对于进程来说其实还是阻塞的。并不完全是非阻塞的。</p><p>所以，阻塞 IO、非阻塞 IO、IO 多路复用都是同步 IO</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>阻塞 IO 和非阻塞 IO 的区别：请求发起调用 IO 会一直被 block，直到操作完成。而 non-blocking IO在kernel还准备数据的情况下会立刻返回。<br>同步 IO 和异步 IO 的区别：一个IO操作有没有对进程造成阻塞。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://segmentfault.com/a/1190000003063859#articleHeader11" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859#articleHeader11</a></li><li><a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">http://blog.csdn.net/historyasamirror/article/details/5778378</a></li></ol>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CronTab 解决周期内未执行完重复执行</title>
      <link href="/2016/08/23/crontab/"/>
      <url>/2016/08/23/crontab/</url>
      <content type="html"><![CDATA[<hr><h2 id="crontab-执行-php-脚本"><a href="#crontab-执行-php-脚本" class="headerlink" title="crontab 执行 php 脚本"></a>crontab 执行 php 脚本</h2><p>linux 下的 crontab 定时任务服务，可以用来定时运行脚本。工作中经常会用到这样的服务，使用起来比较简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/sbin/service crond start  # 开启服务</span><br><span class="line">/sbin/service crond stop  # 停止服务</span><br><span class="line">/sbin/service crond restart #重启服务</span><br><span class="line">/sbin/service crond reload #重新加载服务</span><br><span class="line"></span><br><span class="line">sudo crontab -e #插入一条定时任务</span><br><span class="line">sudo crontab -l #查看所有的 root 用户下的定时任务列表</span><br><span class="line">tail -f /var/log/cron # 实时查看定时任务日志</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 例如，添加如下一条定时任务</span><br><span class="line"># 分 时 日 月 周</span><br><span class="line">*  *  *  *  *   php test.php</span><br></pre></td></tr></table></figure><h2 id="重复执行问题"><a href="#重复执行问题" class="headerlink" title="重复执行问题"></a>重复执行问题</h2><p>最近在工作中经常会用到定时任务，发现当我们的脚步的执行时间（假设：130s）大于定时任务的设定时间（假设：1分钟）时，定时任务会重复开始执行，即上次的任务还没有执行完，下次的任务的又开始执行。往往执行的脚本里的资源是不允许同时两个脚本同时共享资源，即保证操作的原子性。这样会造成执行出错，下面我们来验证一下。</p><p>以下是一个测试的 php 脚本，该脚本执行一次需要 130s </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$time = time();</span><br><span class="line">$id = uniqid(); //一次执行的唯一标示</span><br><span class="line">file_put_contents(&apos;/home/phachon/cron/test.log&apos;, &quot;id: &quot;.$id.&quot; 时间：&quot;.date(&apos;Y-m-d H:i:s&apos;, $time).&quot;-开始\n&quot;, FILE_APPEND);</span><br><span class="line">while(time() - $time &lt; 130) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file_put_contents(&apos;/home/phachon/cron/test.log&apos;, &quot;id: &quot;.$id.&quot; 时间：&quot;.date(&apos;Y-m-d H:i:s&apos;, time()).&quot;-结束\n&quot;, FILE_APPEND);</span><br></pre></td></tr></table></figure><p>然后添加定时任务，每分钟（60s）执行一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * php /home/phachon/cron/test.php</span><br></pre></td></tr></table></figure><p>过一段时间后，查看日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">id: 57bbcd4d10262 时间：2016-08-23 12:13:01-开始</span><br><span class="line">id: 57bbcd890e7f7 时间：2016-08-23 12:14:01-开始</span><br><span class="line">id: 57bbcdc510685 时间：2016-08-23 12:15:01-开始</span><br><span class="line">id: 57bbcd4d10262 时间：2016-08-23 12:15:11-结束</span><br><span class="line">id: 57bbce010a78d 时间：2016-08-23 12:16:01-开始</span><br><span class="line">id: 57bbcd890e7f7 时间：2016-08-23 12:16:11-结束</span><br><span class="line">id: 57bbce3d0f68e 时间：2016-08-23 12:17:01-开始</span><br><span class="line">id: 57bbcdc510685 时间：2016-08-23 12:17:11-结束</span><br><span class="line">id: 57bbce790d90f 时间：2016-08-23 12:18:01-开始</span><br><span class="line">id: 57bbce010a78d 时间：2016-08-23 12:18:11-结束</span><br><span class="line">id: 57bbceb50eef8 时间：2016-08-23 12:19:01-开始</span><br><span class="line">id: 57bbce3d0f68e 时间：2016-08-23 12:19:11-结束</span><br><span class="line">id: 57bbce790d90f 时间：2016-08-23 12:20:11-结束</span><br><span class="line">id: 57bbceb50eef8 时间：2016-08-23 12:21:11-结束</span><br></pre></td></tr></table></figure><p>分析日志我们会发现 id = 57bbcd4d10262 的任务在 12:13:01 开始，但是还没有结束的时候，id=57bbcd890e7f7 和 id=57bbcdc510685 的任务就已经开始了，这样明显存在问题。我们想要的是每次单独执行完后，下一个执行开始:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id: 57bbcd4d10262 时间：2016-08-23 12:13:01-开始</span><br><span class="line">id: 57bbcd4d10262 时间：2016-08-23 12:15:11-结束</span><br><span class="line">id: 57bbcd890e7f7 时间：2016-08-23 12:14:01-开始</span><br><span class="line">id: 57bbcd890e7f7 时间：2016-08-23 12:16:11-结束</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>利用临时文件</li></ol><p>思路很简单，在执行文件的开头先判断是否有一个 test.lock 的文件，如果有 test.lock 文件，则 exit()，如果没有的话，创建 test.lock 文件，然后执行脚本文件，执行完毕删除 test.lock;<br>实现后代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   $time = time();</span><br><span class="line">   $id = uniqid();</span><br><span class="line">   $lock = <span class="string">'/home/phachon/cron/lock/test.lock'</span>;</span><br><span class="line">   <span class="keyword">if</span>(file_exists($lock)) &#123;</span><br><span class="line">       <span class="keyword">exit</span>(<span class="string">'no'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   touch($lock);</span><br><span class="line"></span><br><span class="line">   file_put_contents(<span class="string">'/home/phachon/cron/test2.log'</span>, <span class="string">"id: "</span>.$id.<span class="string">" 时间："</span>.date(<span class="string">'Y-m-d H:i:s'</span>, $time).<span class="string">"-开始\n"</span>, FILE_APPEND);</span><br><span class="line">   <span class="keyword">while</span>(time() - $time &lt; <span class="number">130</span>) &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   file_put_contents(<span class="string">'/home/phachon/cron/test2.log'</span>, <span class="string">"id: "</span>.$id.<span class="string">" 时间："</span>.date(<span class="string">'Y-m-d H:i:s'</span>, time()).<span class="string">"-结束\n"</span>, FILE_APPEND);</span><br><span class="line">   unlink($lock);</span><br></pre></td></tr></table></figure><p>查看日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id: 57bbdd3d6b5e8 时间：2016-08-23 13:21:01-开始</span><br><span class="line">id: 57bbdd3d6b5e8 时间：2016-08-23 13:23:11-结束</span><br><span class="line">id: 57bbddf10ecb9 时间：2016-08-23 13:24:01-开始</span><br><span class="line">id: 57bbddf10ecb9 时间：2016-08-23 13:26:11-结束</span><br></pre></td></tr></table></figure><ol start="2"><li>利用脚本加锁</li></ol><p>思路和第一种方式类似，只是不是用文件判断的方式，而是给文件加锁的方式</p><p>实现代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$fp = fopen(<span class="string">"/tmp/lock.txt"</span>, <span class="string">"w+"</span>);</span><br><span class="line"><span class="comment">// 进行排它型锁定</span></span><br><span class="line"><span class="keyword">if</span> (flock($fp, LOCK_EX | LOCK_NB)) &#123;</span><br><span class="line">   <span class="comment">//执行任务</span></span><br><span class="line">   run(); </span><br><span class="line">   <span class="comment">// 释放锁定</span></span><br><span class="line">   flock($fp, LOCK_UN); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"文件被锁定"</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose($fp);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>第一种和第二种方法本质思路一样，确实也解决了问题，但是这样需要加代码在我们的脚本里，而且，这样其实 crontab 服务还是多了很多不必要的执行，浪费资源。<br>我们需要找到更加好的方法，在执行代码前就已经判断是否可以执行脚本。</p><ol start="3"><li>利用 linux flock 锁机制</li></ol><p>利用 flock（FreeBSD lockf，CentOS下为 flock），在脚本执行前先检测能否获取某个文件锁，以防止脚本运行冲突。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flock [-sxun][-w #] fd#</span><br><span class="line">flock [-sxon][-w #] file [-c] command</span><br></pre></td></tr></table></figure><p>选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-s, --shared:    获得一个共享锁 </span><br><span class="line">-x, --exclusive: 获得一个独占锁 </span><br><span class="line">-u, --unlock:    移除一个锁，脚本执行完会自动丢弃锁 </span><br><span class="line">-n, --nonblock:  如果没有立即获得锁，直接失败而不是等待 </span><br><span class="line">-w, --timeout:   如果没有立即获得锁，等待指定时间 </span><br><span class="line">-o, --close:     在运行命令前关闭文件的描述符号。用于如果命令产生子进程时会不受锁的管控 </span><br><span class="line">-c, --command:   在shell中运行一个单独的命令 </span><br><span class="line">-h, --help       显示帮助 </span><br><span class="line">-V, --version:   显示版本</span><br></pre></td></tr></table></figure><p>锁类型：</p><ul><li>共享锁：多个进程可以使用同一把锁，常被用作读共享锁</li><li>独占锁：同时只允许一个进程使用，又称排他锁，写锁。</li></ul><p>这里我们需要同时只允许一个进程使用，所以使用独占锁。</p><p>修改后的定时任务如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * *  flock -xn /tmp/test.lock -c &apos;php /home/phachon/cron/test.php&apos; &gt;&gt; /home/phachon/cron/cron.log&apos;</span><br></pre></td></tr></table></figure><p>日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id: 57bbf255e4b2b 时间：2016-08-23 14:51:01-开始</span><br><span class="line">id: 57bbf255e4b2b 时间：2016-08-23 14:53:11-结束</span><br><span class="line">id: 57bbf3090eca0 时间：2016-08-23 14:54:01-开始</span><br><span class="line">id: 57bbf3090eca0 时间：2016-08-23 14:56:11-结束</span><br></pre></td></tr></table></figure><p>完美的解决了我们的问题</p><p>总体看来，还是用第三种方法比较好，而且也方便.</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> CronTab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS6.3+Apache2.2+php5.3.8+Mysql5.5.4源码搭建Lump环境</title>
      <link href="/2016/07/29/lump-install/"/>
      <url>/2016/07/29/lump-install/</url>
      <content type="html"><![CDATA[<hr><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><ul><li>虚拟机VMware 下CentOS 6.3最小化安装。</li><li>PHP版本：php-5.3.8.tar.gz</li><li>Apache版本：httpd-2.2.31.tar.gz</li><li>MySql版本：MySql-5.5.45.tar.gz</li></ul><a id="more"></a><h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><h3 id="安装所需要的库文件"><a href="#安装所需要的库文件" class="headerlink" title="安装所需要的库文件"></a>安装所需要的库文件</h3><p>在安装PHP之前，应先安装PHP5需要的最新版本库文件，例如libxml2、libmcrypt以及GD2库等文件。安装GD2库是为了让PHP5支 持GIF、PNG和JPEG图片格式，所以在安装GD2库之前还要先安装最新的zlib、libpng、freetype和jpegsrc等库文件。</p><ul><li>autoconf-2.61.tar.gz</li><li>freetype-2.3.5.tar.gz</li><li>gd-2.0.35.tar.gz</li><li>jpegsrc.v6b.tar.gz</li><li>libmcrypt-2.5.8.tar.gz</li><li>libpng-1.2.31.tar.gz</li><li>libxml2-2.6.30.tar.gz</li><li>zlib-1.2.3.tar.gz</li></ul><p>下载安装包有两种方式：</p><p>(1).利用wget 工具 </p><p>先 yum install –y wget 安装wget .然后用 wget<br><a href="http://www.......com./ksk" target="_blank" rel="noopener">http://www.......com./ksk</a> 下载</p><p>(2).利用 rz sz 命令将windows 下载好的包上传到 linux下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install –y lrzsz  输入rz 弹出windows框选好安装包上传。</span><br><span class="line">cd  /usr/local/src 进入到src目录下，将所有的安装包都放在这个目录下（方便管理）。</span><br></pre></td></tr></table></figure><h3 id="必须先安装gcc、gc-c-用来编译-这里采用yum安装即可。"><a href="#必须先安装gcc、gc-c-用来编译-这里采用yum安装即可。" class="headerlink" title="必须先安装gcc、gc-c++用来编译 这里采用yum安装即可。"></a>必须先安装gcc、gc-c++用来编译 这里采用yum安装即可。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install –y gcc</span><br><span class="line">yum install –y gcc-c++</span><br></pre></td></tr></table></figure><p>会自动安装成功。</p><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><p>命令：tar –zxvf autoconf-2.61.tar.gz<br>其他安装包一样。依次解压。</p><h3 id="make-命令"><a href="#make-命令" class="headerlink" title="make 命令"></a>make 命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yum install -y make</span><br></pre></td></tr></table></figure><h2 id="安装库文件"><a href="#安装库文件" class="headerlink" title="安装库文件"></a>安装库文件</h2><h3 id="安装libxml2"><a href="#安装libxml2" class="headerlink" title="安装libxml2"></a>安装libxml2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/src/libxml2-2.6.30​</span><br><span class="line"># ./configure --prefix=/usr/local/libxml2</span><br><span class="line"># make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="安装libmcrypt"><a href="#安装libmcrypt" class="headerlink" title="安装libmcrypt"></a>安装libmcrypt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/src/libmcrypt-2.5.8</span><br><span class="line"># ./configure --prefix=/usr/local/libmcrypt</span><br><span class="line"># make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/src/zlib-1.2.3</span><br><span class="line"># ./configure    注意：这里直接./configure 不用--prefix</span><br><span class="line"># make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="安装libpng"><a href="#安装libpng" class="headerlink" title="安装libpng"></a>安装libpng</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/src/libpng-1.2.31</span><br><span class="line"># ./configure --prefix=/usr/local/libpng 注意：安装失败。原因很有可能是zlib 没有安装上</span><br><span class="line"># make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="安装jpeg6"><a href="#安装jpeg6" class="headerlink" title="安装jpeg6"></a>安装jpeg6</h3><p>这个软件包安装有些特殊，其它软件包安装时如果目录不存在，会自动创建，但这个软件包安装时需要手动创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /usr/local/jpeg6</span><br><span class="line"># mkdir /usr/local/jpeg6/bin</span><br><span class="line"># mkdir /usr/local/jpeg6/lib</span><br><span class="line"># mkdir /usr/local/jpeg6/include</span><br><span class="line"># mkdir -p /usr/local/jpeg6/man/man1</span><br><span class="line"># cd /usr/local/src/jpeg-6b</span><br><span class="line"># ./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-static</span><br><span class="line"># make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="安装freetype"><a href="#安装freetype" class="headerlink" title="安装freetype"></a>安装freetype</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/src/freetype-2.3.5</span><br><span class="line"># ./configure --prefix=/usr/local/freetype</span><br><span class="line"># make</span><br><span class="line"># make install</span><br></pre></td></tr></table></figure><h3 id="安装autoconf"><a href="#安装autoconf" class="headerlink" title="安装autoconf"></a>安装autoconf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/src/autoconf-2.61</span><br><span class="line"># ./configure</span><br><span class="line"># make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="安装GD库"><a href="#安装GD库" class="headerlink" title="安装GD库"></a>安装GD库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/src/gd-2.0.35</span><br><span class="line"># ./configure \</span><br><span class="line">​--prefix=/usr/local/gd2/ \</span><br><span class="line">​--enable-m4_pattern_allow \</span><br><span class="line">​--with-zlib=/usr/local/zlib/ \</span><br><span class="line"> --with-jpeg=/usr/local/jpeg6/ \</span><br><span class="line"> --with-png=/usr/local/libpng/ \</span><br><span class="line"> --with-freetype=/usr/local/freetype/</span><br><span class="line"># make</span><br></pre></td></tr></table></figure><p>出现错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make[2]: *** [gd_png.lo] Error 1</span><br><span class="line">make[2]: Leaving directory `/usr/local/src/gd-2.0.35&apos;</span><br><span class="line">make[1]: *** [all-recursive] Error 1</span><br><span class="line">make[1]: Leaving directory `/usr/local/src/gd-2.0.35&apos;make: *** [all] Error 2</span><br></pre></td></tr></table></figure><p>分析：这个问题是因为gd库中的gd_png.c这个源文件中包含png.h时，png.h没有找到导致的。</p><p>解决：在编译文件里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vi gd_png.c</span><br><span class="line"># 将include “png.h” 改成 include “/usr/local/libpng/include/png.h”</span><br></pre></td></tr></table></figure><p>其中/usr/local/libpng/为libpng安装路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># make install</span><br></pre></td></tr></table></figure><h3 id="开启80、3306端口"><a href="#开启80、3306端口" class="headerlink" title="开启80、3306端口"></a>开启80、3306端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure><p>重启防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><p>修改/etc/selinux/config 文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br><span class="line"># 将SELINUX=enforcing改为SELINUX=disabled</span><br></pre></td></tr></table></figure><p>重启防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart</span><br></pre></td></tr></table></figure><h2 id="安装-Apache"><a href="#安装-Apache" class="headerlink" title="安装 Apache"></a>安装 Apache</h2><h3 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/src/httpd-2.2.9</span><br><span class="line"># ./configure \</span><br><span class="line">  --prefix=/usr/local/apache2 \</span><br><span class="line">  --sysconfdir=/etc/httpd \</span><br><span class="line">  --with-z=/usr/local/zlib \</span><br><span class="line">  --with-included-apr \</span><br><span class="line">  --enable-so \</span><br><span class="line">  --enable-deflate=shared \</span><br><span class="line">  --enable-expires=shared \</span><br><span class="line">  --enable-rewrite=shared \</span><br><span class="line">  --enable-static-support</span><br><span class="line"># make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="配置Apache"><a href="#配置Apache" class="headerlink" title="配置Apache"></a>配置Apache</h3><p>启动Apache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#/usr/local/apache2/bin/apachectl start</span><br></pre></td></tr></table></figure><p>如果提示httpd: Could not reliably determine the server’s fully qualified domain name, using ::1 for ServerName</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/http/httpd.conf</span><br></pre></td></tr></table></figure><p>将里面的#ServerName <a href="http://www.example.com:80注释去掉,改成ServerName" target="_blank" rel="noopener">www.example.com:80注释去掉,改成ServerName</a> localhost:80 即可。再启动httpd</p><p>关闭Apache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/apache2/bin/apachectl stop</span><br></pre></td></tr></table></figure><p>查看80端口是否开启 ，之前我们已经开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># netstat -tnl|grep 80</span><br></pre></td></tr></table></figure><p>然后可以通过浏览器访问<a href="http://localhost:80，如果页面显示正常显示测试页面，即表示apache已安装并启动成功。" target="_blank" rel="noopener">http://localhost:80，如果页面显示正常显示测试页面，即表示apache已安装并启动成功。</a></p><p>添加自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;/usr/local/apache2/bin/apachectl start&quot; &gt;&gt; /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure><h2 id="安装-Mysql"><a href="#安装-Mysql" class="headerlink" title="安装 Mysql"></a>安装 Mysql</h2><h3 id="cmake的安装"><a href="#cmake的安装" class="headerlink" title="cmake的安装"></a>cmake的安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost]# tar -zxv -f cmake-2.8.10.2.tar.gz // 解压压缩包</span><br><span class="line">[root@localhost local]# cd cmake-2.8.10.2</span><br><span class="line">[root@localhost cmake-2.8.10.2]# ./configure</span><br><span class="line">[root@localhost cmake-2.8.10.2]# make</span><br><span class="line">[root@localhost cmake-2.8.10.2]# make install</span><br></pre></td></tr></table></figure><h3 id="将cmake永久加入系统环境变量"><a href="#将cmake永久加入系统环境变量" class="headerlink" title="将cmake永久加入系统环境变量"></a>将cmake永久加入系统环境变量</h3><p>用vi在文件/etc/profile文件中增加变量，使其永久有效，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# vi /etc/profile</span><br></pre></td></tr></table></figure><p>在文件末尾追加以下两行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=/usr/local/cmake-2.8.10.2/bin:$PATHexport PATH</span><br></pre></td></tr></table></figure><p>执行以下代码使刚才的修改生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# source /etc/profile</span><br></pre></td></tr></table></figure><p>用 export 命令查看PATH值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# echo $PATH</span><br></pre></td></tr></table></figure><p>注意：也可以直接yum install –y cmake 安装</p><h3 id="yum-install-y-ncurses-devel"><a href="#yum-install-y-ncurses-devel" class="headerlink" title="yum install -y ncurses-devel"></a>yum install -y ncurses-devel</h3><p>必须安装，不然会出错</p><h3 id="创建mysql的安装目录及数据库存放目录"><a href="#创建mysql的安装目录及数据库存放目录" class="headerlink" title="创建mysql的安装目录及数据库存放目录"></a>创建mysql的安装目录及数据库存放目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost]# mkdir -p /usr/local/mysql //安装mysql</span><br><span class="line">[root@localhost]# mkdir -p /usr/local/mysql/data //存放数据库</span><br></pre></td></tr></table></figure><h3 id="创建mysql用户及用户组"><a href="#创建mysql用户及用户组" class="headerlink" title="创建mysql用户及用户组"></a>创建mysql用户及用户组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost] groupadd mysql[root@localhost] useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure><h3 id="编译安装mysql"><a href="#编译安装mysql" class="headerlink" title="编译安装mysql"></a>编译安装mysql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# tar -zxv -f mysql-5.5.45.tar.gz //解压</span><br><span class="line">[root@localhost local]# cd mysql-5.5.45</span><br><span class="line"> cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \</span><br><span class="line"> -DMYSQL_UNIX_ADDR=/tmp/mysql.sock \</span><br><span class="line"> -DDEFAULT_CHARSET=utf8 \</span><br><span class="line"> -DDEFAULT_COLLATION=utf8_general_ci \</span><br><span class="line"> -DWITH_EXTRA_CHARSETS=all \</span><br><span class="line"> -DWITH_MYISAM_STORAGE_ENGINE=1 \</span><br><span class="line"> -DWITH_INNOBASE_STORAGE_ENGINE=1 \</span><br><span class="line"> -DWITH_MEMORY_STORAGE_ENGINE=1 \</span><br><span class="line"> -DWITH_READLINE=1 \</span><br><span class="line"> -DENABLED_LOCAL_INFILE=1 \</span><br><span class="line"> -DMYSQL_DATADIR=/usr/local/mysql/data \</span><br><span class="line"> -DMYSQL_USER=mysql</span><br><span class="line">[root@localhost mysql-5.5.45]# make</span><br><span class="line">[root@localhost mysql-5.5.45]# make install</span><br></pre></td></tr></table></figure><h3 id="检验是否安装成功"><a href="#检验是否安装成功" class="headerlink" title="检验是否安装成功"></a>检验是否安装成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql-5.5.45]</span><br><span class="line"># cd /usr/local/mysql/</span><br><span class="line">[root@localhost mysql]# ls</span><br><span class="line">bin COPYING data docs include INSTALL-BINARY lib man mysql-test README scripts share sql-bench support-files</span><br></pre></td></tr></table></figure><p>有bin等以上文件的话，恭喜你已经成功安装了mysql。</p><h3 id="设置mysql目录权限"><a href="#设置mysql目录权限" class="headerlink" title="设置mysql目录权限"></a>设置mysql目录权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]</span><br><span class="line"># cd /usr/local/mysql //把当前目录中所有文件的所有者设为root，所属组为mysql</span><br><span class="line">[root@localhost mysql]</span><br><span class="line"># chown -R root:mysql .</span><br><span class="line">[root@localhost mysql]# chown -R mysql:mysql data</span><br></pre></td></tr></table></figure><h3 id="将mysql的启动服务添加到系统服务中"><a href="#将mysql的启动服务添加到系统服务中" class="headerlink" title="将mysql的启动服务添加到系统服务中"></a>将mysql的启动服务添加到系统服务中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# cp support-files/my-medium.cnf /etc/my.cnfcp：是否覆盖&quot;/etc/my.cnf&quot;？ y</span><br></pre></td></tr></table></figure><h3 id="创建系统数据库的表"><a href="#创建系统数据库的表" class="headerlink" title="创建系统数据库的表"></a>创建系统数据库的表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# cd /usr/local/mysql</span><br><span class="line">[root@localhost mysql]# scripts/mysql_install_db --user=mysql</span><br></pre></td></tr></table></figure><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /root/.bash_profile</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATH=$PATH:$HOME/bin:/usr/local/mysql/bin:/usr/local/mysql/lib</span><br><span class="line">[root@localhost ~]# source /root/.bash_profile //使刚才的修改生效</span><br></pre></td></tr></table></figure><h3 id="手动启动mysql"><a href="#手动启动mysql" class="headerlink" title="手动启动mysql"></a>手动启动mysql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/local/mysql</span><br><span class="line">[root@localhost mysql]# ./bin/mysqld_safe --user=mysql &amp; //启动MySQL，但不能停止</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root -p shutdown //此时root还没密码，所以为空值，提示输入密码时，直接回车即可。</span><br></pre></td></tr></table></figure><h3 id="将mysql的启动服务添加到系统服务中-1"><a href="#将mysql的启动服务添加到系统服务中-1" class="headerlink" title="将mysql的启动服务添加到系统服务中"></a>将mysql的启动服务添加到系统服务中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# cp support-files/mysql.server /etc/init.d/mysql</span><br></pre></td></tr></table></figure><h3 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# service mysql startStarting MySQL... ERROR! The server quit without updating PID file (/usr/local/mysql/data/localhost.localdomain.pid).</span><br></pre></td></tr></table></figure><p>启动失败：我这里是权限问题，先改变权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# chown -R mysql:mysql /usr/local/mysql</span><br></pre></td></tr></table></figure><p>接着启动服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# /etc/init.d/mysql start</span><br></pre></td></tr></table></figure><h3 id="修改MySQL的root用户的密码以及打开远程连接"><a href="#修改MySQL的root用户的密码以及打开远程连接" class="headerlink" title="修改MySQL的root用户的密码以及打开远程连接"></a>修改MySQL的root用户的密码以及打开远程连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# mysql -u root mysql</span><br><span class="line"></span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; desc user;</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO root@&quot;%&quot; IDENTIFIED BY &quot;root&quot;; //为root添加远程连接的能力</span><br><span class="line">mysql&gt; update user set Password = password(&apos;123456&apos;) where User=&apos;root&apos;; //设置root用户密码</span><br><span class="line">mysql&gt; select Host,User,Password from user where User=&apos;root&apos;;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure><h3 id="重新登录"><a href="#重新登录" class="headerlink" title="重新登录"></a>重新登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# mysql -u root -pEnter password:123456</span><br></pre></td></tr></table></figure><p>若还不能进行远程连接，关闭防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost]# /etc/rc.d/init.d/iptables stop</span><br></pre></td></tr></table></figure><h2 id="安装-php"><a href="#安装-php" class="headerlink" title="安装 php"></a>安装 php</h2><h3 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/src/php-5.3.8</span><br><span class="line"># ./configure \</span><br><span class="line"> --prefix=/usr/local/php \</span><br><span class="line"> --with-config-file-path=/usr/local/php/etc \</span><br><span class="line"> --with-apxs2=/usr/local/apache2/bin/apxs \</span><br><span class="line"> --with-mysql=/usr/local/mysql/ \</span><br><span class="line"> --with-libxml-dir=/usr/local/libxml2/ \</span><br><span class="line"> --with-png-dir=/usr/local/libpng/ \</span><br><span class="line"> --with-jpeg-dir=/usr/local/jpeg6/ \</span><br><span class="line"> --with-freetype-dir=/usr/local/freetype/ \</span><br><span class="line">​--with-gd=/usr/local/gd2/ \</span><br><span class="line"> --with-zlib-dir=/usr/local/zlib/ \</span><br><span class="line">​--with-mcrypt=/usr/local/libmcrypt/ \</span><br><span class="line">​--with-mysqli=/usr/local/mysql/bin/mysql_config \</span><br><span class="line">​--enable-mbstring=all \</span><br><span class="line">​--enable-sockets</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="配置PHP"><a href="#配置PHP" class="headerlink" title="配置PHP"></a>配置PHP</h3><p>创建配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cp php.ini-development /usr/local/php/etc/php.ini</span><br></pre></td></tr></table></figure><p>使用vi编辑apache配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/httpd/httpd.conf</span><br></pre></td></tr></table></figure><p>最后一行添加这一条代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Addtype application/x-httpd-php .php .phtml</span><br></pre></td></tr></table></figure><p>重启Apache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/apache2/bin/apachectl restart</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="编写info-php文件，查看php配置详细"><a href="#编写info-php文件，查看php配置详细" class="headerlink" title="编写info.php文件，查看php配置详细"></a>编写info.php文件，查看php配置详细</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#vi /usr/local/apache2/htdocs/info.php</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> CentOS </tag>
            
            <tag> Mysql </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅析 php 的几种运行方式</title>
      <link href="/2016/07/29/php-run-type/"/>
      <url>/2016/07/29/php-run-type/</url>
      <content type="html"><![CDATA[<hr><h2 id="PHP-的几种运行方式"><a href="#PHP-的几种运行方式" class="headerlink" title="PHP 的几种运行方式"></a>PHP 的几种运行方式</h2><ol><li>CGI</li><li>FAST-CGI</li><li>Web-module</li><li>CLI</li></ol><a id="more"></a><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>CGI (Common Gateway Interface) 是通用网关型接口,CGI是外部应用程序（CGI程序）与Web服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的过程。简单的说，就是当你的 php引擎和web服务器相互传递消息时，CGI 规定了一套标准来规范如何传递数据以及数据传递的格式。</p><p>当 web 服务器接收到一个请求时，就会启动一个 CGI 进程，这里就会通知到PHP 引擎，然后去解析 php.ini 文件，开始处理请求，并且将处理的请求的结果以标准的格式返回给 web 服务器，并退出进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title:CGI工作原理</span><br><span class="line">浏览器-&gt;web服务器:发送请求</span><br><span class="line">web服务器-&gt;CGI应用程序(php引擎):启动一个 CGI 进程</span><br><span class="line">CGI应用程序(php引擎)-&gt;web服务器:发送解析好的信息</span><br><span class="line">web服务器-&gt;浏览器:发送 html 信息</span><br></pre></td></tr></table></figure><p>显而易见的是，这样每一个请求过来的话都会重新去启动一个 CGI 进程,关键是每个进程又都会去启动引擎去解析 php.ini 文件，这样当请求多的时候，效率会非常的低。因而，已经逐渐被抛弃。</p><p>注意：需要明确的是 CGI 只是一套接口标准，具体的实现程序才是用来启动进程的。比如根据 CGI 实现的 php-cgi 程序。</p><h2 id="FAST-CGI"><a href="#FAST-CGI" class="headerlink" title="FAST-CGI"></a>FAST-CGI</h2><p>既然 CGI 是如此的效率低下，聪明的人类肯定能够想出更好的方法来使得 CGI 更加高效，对的，这就是 FAST-CGI。</p><p>FAST-CGI 也是一种通用网关型接口，是建立在 CGI 的基础上进化而来,FastCGI 像是一个常驻(long-live)型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute 模式)。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。<br>简单理解呢，大概是这样：当web服务器启动时，会载入Fast-CGI 进程管理器，FastCGI进程管理器会同时开启多个 CGI 子进程，相当于一个进程池，当 web 请求到来时，会选择一个 CGI 解释器并连接，处理完成后将信息返回给web服务器，这时候，该子进程又会回到进程管理器中继续等待下一个连接，所以这样不需要每次都去重新启动进程，加载配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title:fast-cgi 工作原理</span><br><span class="line">web服务器-&gt;fastcgi进程管理:启动载入</span><br><span class="line">fastcgi进程管理-&gt;cgi子进程:启动多个</span><br><span class="line">web服务器-&gt;fastcgi进程管理:请求</span><br><span class="line">fastcgi进程管理-&gt;cgi子进程:连接一个</span><br><span class="line">cgi子进程-&gt;web服务器:返回解析并重新等待新的请求</span><br></pre></td></tr></table></figure><p>php-cgi 只是用来处理 cgi 进程的程序，那 php fast-cgi 进程管理器是怎么实现的呢，php-fpm ,对的，就是它，php-fmp 用来管理和调度这些 php fast-cgi 进程。</p><p>注意：还是需要明确一下，fast-cgi 也只是一套协议标准，php fast-cgi才是具体的实现程序，php-fpm是实现了对 fast-cgi 的进程管理。</p><h2 id="Web-module"><a href="#Web-module" class="headerlink" title="Web-module"></a>Web-module</h2><p>这个简称为 web 模块加载模式，想必用 apache 搭建过 php 环境的应该都了解，apahce 需要加载 mod-php5 模块，这个模块就是用来将 Apache 传递过来的 php 文件的请求，并处理这些请求，最终将处理的结果返回给 apache。在 apache 的配置文件中配置好了 php 模块，php 模块就会通过注册 apache2 的 ap_hook_post_config 挂钩，实现请求与返回。</p><p>windows 下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadModule php5_module d:/server/php/php5apache2_2.dll</span><br></pre></td></tr></table></figure><p>linux 下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadModule php5_module modules/mod_php5.so</span><br></pre></td></tr></table></figure><p>该模块是 apache 在CGI的基础上进行的一种扩展，加快PHP的运行效率</p><h2 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h2><p>php-CLI：PHP Command Line Interface</p><p>即 php 在命令行运行的接口，当然是相对于以上三种方式（web 请求）来说的</p><p>优点：</p><ul><li>多进程池，子进程完成后，内核会回收掉</li><li>主进程只进行任务分发</li></ul><p>CLI 模式在 windows 和 linux 都可以运行。</p><p>以上就是 php 的几种主要的运行方式，除此之外，还有一种运行方式是 ISAPI（Internet Server Application Program Interface）是微软提供的一套面向Internet服务的API接口，在这里就不多介绍了。因为现在几乎都是在 Linux 下部署 php 应用了。</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> CGI </tag>
            
            <tag> FAST-CGI </tag>
            
            <tag> PHP-FPM </tag>
            
            <tag> CLI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP 魔术方法之 __call 与 __callStatic</title>
      <link href="/2016/07/28/php-call-callStatic/"/>
      <url>/2016/07/28/php-call-callStatic/</url>
      <content type="html"><![CDATA[<hr><h2 id="call-方法的使用"><a href="#call-方法的使用" class="headerlink" title="__call 方法的使用"></a>__call 方法的使用</h2><p>定义：在对象中调用一个不可访问方法时，__call() 会被调用。</p><a id="more"></a><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * __call 测试 </span><br><span class="line"> * @author phachon@163.com</span><br><span class="line"> */</span><br><span class="line">class Test &#123;</span><br><span class="line"></span><br><span class="line">public function __construct() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function show() &#123;</span><br><span class="line">echo &quot;show 一下\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function __call($method, $arguments) &#123;</span><br><span class="line">echo &quot;不可访问的方法都来我这里了\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test = new Test(); </span><br><span class="line">$test-&gt;show();//输出: show 一下</span><br><span class="line">$test-&gt;close(); //输出: 不可访问的方法都来我这里来了</span><br></pre></td></tr></table></figure><p>上面例子中调用 close 方法时不存在，所以被 __call 接收了。</p><p>但是如果调用类里面的方法是 protected 或者是 private 的时候，是否可以被 __call 接收呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * __call 测试 </span><br><span class="line"> * @author phachon@163.com</span><br><span class="line"> */</span><br><span class="line">class Test &#123;</span><br><span class="line"></span><br><span class="line">public function __construct() &#123;</span><br><span class="line">echo &quot;我是构造方法\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function show() &#123;</span><br><span class="line">echo &quot;show 一下\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function __call($method, $arguments) &#123;</span><br><span class="line">echo &quot;不可访问的方法都来我这里了\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected function _sing() &#123;</span><br><span class="line">echo &quot;我是唱歌的&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private function _run() &#123;</span><br><span class="line">echo &quot;我是跑步的&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test = new Test();</span><br><span class="line">$test-&gt;show(); //输出：show 一下</span><br><span class="line">$test-&gt;_sing(); //输出：不可访问的方法都来我这里了</span><br><span class="line">$test-&gt;_run();  //输出：不可访问的方法都来我这里了</span><br><span class="line">$test-&gt;close(); //输出：不可访问的方法都来我这里了</span><br></pre></td></tr></table></figure><p>事实证明除了没有定义的方法以及 private 和 protected 方法都会被魔术方法 __call 接收，所以定义为调用一个不可访问的方法时才被调用是十分准确的。（之前听有些人说是当访问一个未被定义的方法时被调用这是不准确的）</p><p>注意：__call 在使用时必须声明为 public 并且，方法必须有带两个参数，一个是 被调用的方法名，一个是方法携带的参数。</p><h2 id="callStatic-方法的使用"><a href="#callStatic-方法的使用" class="headerlink" title="__callStatic 方法的使用"></a>__callStatic 方法的使用</h2><p>定义：用静态方式中调用一个不可访问方法时，__callStatic() 会被调用。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * __callStatic 测试 </span><br><span class="line"> * @author phachon@163.com</span><br><span class="line"> */</span><br><span class="line">class Test &#123;</span><br><span class="line"></span><br><span class="line">public function __construct() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static function show() &#123;</span><br><span class="line">echo &quot;show 一下\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static function __callStatic($className, $arguments) &#123;</span><br><span class="line">echo &quot;不可访问的静态方法来这里吧&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test::show(); //输出：show 一下</span><br><span class="line">Test::close(); //输出：不可访问的静态方法来这里吧</span><br></pre></td></tr></table></figure><p>同样对于没有定义的方法以及 private 和 protected 的静态方法，都会被__callStatic 接收。</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 常用命令总结</title>
      <link href="/2016/07/28/linux-command/"/>
      <url>/2016/07/28/linux-command/</url>
      <content type="html"><![CDATA[<hr><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><ul><li>who 显示在线登录用户</li><li>whoami 显示当前操作的用户</li><li>hostname 主机名</li><li>top 显示当前耗费最多的进程以及内存消耗</li><li>ps -aux 显示所有的进程信息</li><li>df 查看磁盘所占大小</li><li>-h 带单位</li><li>ifconfig 网络信息</li><li>ping 测试网络连接</li><li>netstat 网络状态信息</li><li>kill 杀死进程</li><li>clear 清屏</li><li>shutdown<ul><li>-r 关机重启</li><li>-h 关机不重启</li><li>now  立刻关机</li></ul></li><li>reboot   重启</li></ul><a id="more"></a><h2 id="目录相关"><a href="#目录相关" class="headerlink" title="目录相关"></a>目录相关</h2><ul><li>cd 切换目录</li><li>ls 列出目录下的文件或文件夹</li><li>-l 列出文件详细信息</li><li>-s 列出所有的文件及目录（包括隐藏）</li><li>-f 列出的文件显示文件类型</li><li>mkdir 创建目录</li><li>-p 递归创建(父级不存在创建)</li><li>pwd 显示当前目录路径</li><li>rmdir 删除目录</li><li>du 查看目录所占大小</li><li>-h 带有单位显示目录所占大小</li><li>zip 打包成 zip 文件</li><li>unzip 解压 zip 文件 </li><li>tar 打包压缩<ul><li>-c  归档文件</li><li>-x  解压</li><li>-z  gzip压缩文件</li><li>-j   bzip2压缩文件</li><li>-v  显示压缩或解压缩过程</li><li>-f  使用档名<br>压缩：tar -zcvf /home/test.tar.gz /home/test<br>解压：tar -zxvf test.tar.gz ./</li></ul></li></ul><h2 id="用户权限相关"><a href="#用户权限相关" class="headerlink" title="用户权限相关"></a>用户权限相关</h2><ul><li>useradd 添加用户</li><li>-c 注释信息</li><li>-d 目录指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录</li><li>-g 用户组 指定用户所属的用户组</li><li>-G 用户组，用户组指定用户所属的附加组</li><li>-s Shell文件 指定用户的登录Shell</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号</li><li>useradd –d /usr/sam -m sam</li><li>usermod 修改用户</li><li>参数和 useradd 一样</li><li>userdel 删除用户</li><li>-r 连同目录一起删除</li><li>普通用户增加 root 权限</li><li>修改 /etc/sudoers 文件，找到下面一行，把前面的注释（#）去掉<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Allows people in group wheel to run all commands</span><br><span class="line">%wheel    ALL=(ALL)    ALL</span><br></pre></td></tr></table></figure></li></ul><p>然后修改用户，使其属于root组（wheel），命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g root phachon</span><br></pre></td></tr></table></figure><p>修改完毕，现在可以用 phachon 帐号登录，然后用命令 su - ，即可获取root 权限</p><ul><li>sudo 命令可以不需要 root 密码来以 root 的权限执行</li><li>修改 /etc/sudoers 文件，找到下面一行，在root下面添加一行，如下所示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line">phachon   ALL=(ALL)     ALL  #sudo 需要密码 </span><br><span class="line">phachon ALL=(ALL)   NOPASSWD:ALL  # sudo 不需要密码</span><br></pre></td></tr></table></figure><p>ok , 你就可以用  root 权限了</p><ul><li>chown 更改文件的用户用户组</li><li><p>sudo chown [-R] owner[:group] {File|Directory}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown redis:redis ./redis</span><br></pre></td></tr></table></figure></li><li><p>更改文件权限</p></li></ul><p>首先先来了解一下三种基本权限<br>r  -&gt;  读         数值表示为 4<br>w  -&gt;  写         数值表示为 2<br>x  -&gt;  可执行  数值表示为 1</p><p>假如某一个文件的权限为 -rw-rw-r–</p><p>-rw-rw-r–一共十个字符，分成四段。<br>第 1 个字符“-”表示普通文件，“l”链接，“d”表示目录<br>第2、3、4个字符“rw-”表示当前所属用户的权限，所以用数值表示为4+2=6<br>第5、6、7个字符“rw-”表示当前所属组的权限，所以用数值表示为4+2=6<br>第8、9、10个字符“r–”表示其他用户权限，所以用数值表示为2<br>所以操作此文件的权限用数值表示为662</p><p>777 对应的权限是 -rwxrwxrwx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 0777 test.php  修改 test.php 权限为 777</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Wamp 环境的搭建</title>
      <link href="/2016/07/26/wamp-install/"/>
      <url>/2016/07/26/wamp-install/</url>
      <content type="html"><![CDATA[<hr><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>Apache是一种b/s结构的软件，Apache属于s服务端</p><p>下载地址：<a href="http://httpd.apache.org/download.cgi" target="_blank" rel="noopener">http://httpd.apache.org/download.cgi</a> 选择相应的版本下载</p><p>我这里下载的是 httpd-2.2.22-win32-x86-no_ssl.msi<br>解释一下下载的文件：<br>版本：2.2.22<br>操作系统：win32 x86<br>是否提供ssl: no_ssl 不提供</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>(1) 双击点击下载好的文件：httpd-2.2.22-win32-x86-no_ssl.msi</p><p>(2) 点击 next,进入协议页面，勾选同意。</p><p><img src="http://img.blog.csdn.net/20160726105923921" alt="这里写图片描述"></p><p>(3) 点击两次 next 进入到服务器配置页面</p><p><img src="http://img.blog.csdn.net/20160726110132719" alt="这里写图片描述"></p><p>(4) 点击next，进入配置模式，选择自定义配置模式</p><p><img src="http://img.blog.csdn.net/20160726110226955" alt="这里写图片描述"></p><p>(5) 点击next，进入路径配置界面</p><p>在 D 盘下创建一个server 目录（不要使用中文）<br>将安装路劲选择到创建是server目录，并在server目录下创建一个Apache目录</p><p><img src="http://img.blog.csdn.net/20160726110753503" alt="这里写图片描述"></p><p>(6) 点击next，进入到准备安装界面，点击install进行安装，之后点击finish完成,在电脑的任务栏会出现 apache 的图标，绿色代表已开启</p><p><img src="http://img.blog.csdn.net/20160726111119301" alt="这里写图片描述"></p><p>(7) 验证是否成功</p><p>在浏览器输入 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> ，页面 输出 It, works! 证明安装成功。</p><p>(8) apache 安装后的目录结构说明</p><p>D:/server/apache 下</p><ul><li>bin: Apache 的可执行文件</li><li>cgi-bin：CGI 可执行文件</li><li>conf：配置文件</li><li>error：错误日志</li><li>htdocs：网站默认根目录</li><li>icons：图标</li><li>logs：日志</li><li>modules：Apache 可加载的模块</li></ul><p>D:server/apache/bin</p><ul><li>httpd.exe apache 的服务端</li></ul><p>(9) 几个简单的 httpd 命令</p><ul><li>M：Apache可以加载的模块（功能）</li><li>l：当前Apache已经加载的模块</li><li>t：验证配置文件的语法错误</li></ul><p>在cmd控制台下，进入到 Apache 的bin目录，使用 httpd.exe 或者httpd 命令+空格+参数</p><p><img src="http://img.blog.csdn.net/20160726112532329" alt="这里写图片描述"></p><p>配置文件验证</p><p><img src="http://img.blog.csdn.net/20160726112622574" alt="这里写图片描述"></p><p>修改Apache配置文件：Apache/conf/httpd.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Servername www.test.com:80 #将前面的&apos;#&apos;号去掉即可开启</span><br></pre></td></tr></table></figure><p>修改完配置文件后记得要重启 apache ,否则配置不会生效。</p><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql是一种c/s结构的软件。</span><br></pre></td></tr></table></figure><p>当前是在为web服务器增加可以访问数据库的能力。<br>下载地址：<a href="http://www.mysql.com/downloads/" target="_blank" rel="noopener">http://www.mysql.com/downloads/</a><br>我这里下载的是:mysql-5.5-win32</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>(1) 双击文件，进入安装界面</p><p><img src="http://img.blog.csdn.net/20160726113926564" alt="这里写图片描述"></p><p>(2) 点击next，进入协议界面，选中同意协议，点击next进入配置模式</p><p><img src="http://img.blog.csdn.net/20160726114012955" alt="这里写图片描述"></p><p>(3) 点击自定义安装，进入路径配置界面</p><p>在 D 盘 server 下创建一个目录 mysql<br>修改mysql的安装目录</p><p><img src="http://img.blog.csdn.net/20160726114215284" alt="这里写图片描述"></p><p>修改数据路径</p><p><img src="http://img.blog.csdn.net/20160726114318206" alt="这里写图片描述"></p><p>(4) 点击 next 进入到准备安装界面，点击install进行安装，安装完成之后进入到安装完成页面,勾选 finish 完成</p><p><img src="http://img.blog.csdn.net/20160726114504747" alt="这里写图片描述"></p><p>(5) 点击next进行配置，进入到配置选择界面</p><p><img src="http://img.blog.csdn.net/20160726114622061" alt="这里写图片描述">    </p><p>(6) 选择详细配置，点击next，进入到服务器类型配置界面</p><p><img src="http://img.blog.csdn.net/20160726114718625" alt="这里写图片描述"></p><p>(7) 选择开发者机器，点击next，进入数据库用途配置</p><p><img src="http://img.blog.csdn.net/20160726114758798" alt="这里写图片描述"></p><p>(8) 选择多功能数据库，点击next，进入到InnoDB驱动选择界面，可以直接点击next跳过</p><p><img src="http://img.blog.csdn.net/20160726114852599" alt="这里写图片描述"></p><p>(9) 配置并发选项</p><p><img src="http://img.blog.csdn.net/20160726114939037" alt="这里写图片描述"></p><p>(10) 选择手动选择，设置为默认的并发量15个，点击next，进入网络设置界面</p><p><img src="http://img.blog.csdn.net/20160726115039880" alt="这里写图片描述"></p><p>(11) 勾选防火墙放行，其他默认，点击next进入到字符集设置界面</p><p><img src="http://img.blog.csdn.net/20160726115144085" alt="这里写图片描述"></p><p>(12) 选择手动选择，设置字符集为utf8，点击next进入windows设置</p><p><img src="http://img.blog.csdn.net/20160726115223320" alt="这里写图片描述"></p><p>(13) 勾选设置环境变量，点击next进入安全选项配置</p><p><img src="http://img.blog.csdn.net/20160726115259524" alt="这里写图片描述"></p><p>(14) 输入root用户的密码，点击next进入到准备配置的界面</p><p><img src="http://img.blog.csdn.net/20160726115344086" alt="这里写图片描述"></p><p>(15) 点击excute执行配置项，需要上面的四项都成功打上勾才算配置成功,点击finish完成安装。</p><p><img src="http://img.blog.csdn.net/20160726115423167" alt="这里写图片描述"></p><p>(16) 检测是否安装成功</p><p>cmd控制台输入mysql –uroot –proot</p><p><img src="http://img.blog.csdn.net/20160726115550278" alt="这里写图片描述"></p><p>(17) mysql 安装目录结构解释</p><ul><li>bin：执行文件</li><li>data：数据存放目录</li><li>include：包含文件</li><li>lib：核心文件</li><li>share：共享文件</li><li>my.ini：mysql 核心配置文件</li></ul><p>mysql 的 bin 目录</p><ul><li>mysql.exe mysql 的客户端</li><li>mysqld.exe mysql 服务器端</li></ul><h2 id="配置PHP"><a href="#配置PHP" class="headerlink" title="配置PHP"></a>配置PHP</h2><h3 id="下载-2"><a href="#下载-2" class="headerlink" title="下载"></a>下载</h3><p>php 下载地址：<a href="http://www.php.net/downloads.php" target="_blank" rel="noopener">http://www.php.net/downloads.php</a></p><p>选择对应的版本下载</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在 D:server/ 下创建 php 目录,将下载的 php 文件压缩包解压到该文件夹下</p><p>(1) 配置 apache,让 apache 能够识别 php<br>在Apache中加载PHP模块（把PHP当做Apache的一个模块来运行）。/apache/conf/httpd.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LoadModule php5_module d:/server/php/php5apache2_2.dll #加载PHP，当做Apache的模块 加载模式：LoadModule 模块名（不能随意） 模块的动态链接库所在的</span><br><span class="line">AddType application/x-httpd-php .php #增加PHP处理模块需要处理的文件,将以.php结尾的文件交给PHP模块去处理</span><br></pre></td></tr></table></figure><p>(2) 配置 php ，让  php 去连接 mysql</p><p>PHP本身没有能力去操作mysql，需要借助外部扩展才可以。在PHP中，提供一套mysql的扩展，能够连接mysql服务器。</p><p>在 php 的安装目录下有两个配置文件 php.ini-development php.ini-production,复制一份，修改为 php.ini 文件。打开 php.ini</p><p>将php的配置文件，加载到Apache的配置文件中。 /apache/conf/httpd.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHPIniDir d:/server/php/php.ini #增加php配置文件的路径</span><br></pre></td></tr></table></figure><p>开启mysql扩展。/php/php.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;extesion=php_mysql.dll #将前面的 ; 号去掉即可开启</span><br></pre></td></tr></table></figure><p>指定扩展文件所在的目录。/php/php.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;extension_dir = &quot;ext&quot;</span><br><span class="line">extension_dir = d:server/php/ext</span><br></pre></td></tr></table></figure><p>修改 php 时区</p><p>在php的配置文件中去修改。/php/php.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;date_timezone = </span><br><span class="line">date_timezone = PRC #中国时区</span><br></pre></td></tr></table></figure><h2 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h2><p>Apache的虚拟主机分为两种：基于IP地址的虚拟主机，基于域名的虚拟主机</p><p>基于域名的虚拟主机：通过域名来是的Apache区分对应的网站（文件夹）</p><p>Apache提供了多个位置可以用来配置虚拟主机，httpd.conf和/extra/httpd_vhost.conf<br>httpd.conf配置之后，只需要直接重启Apache即可生效<br>/extra/httpd_vhost.conf配置之后，需要在httpd.conf下加载对应的配置文件</p><h3 id="先加载虚拟主机配置文件"><a href="#先加载虚拟主机配置文件" class="headerlink" title="先加载虚拟主机配置文件"></a>先加载虚拟主机配置文件</h3><p>找到 Include conf/extra/http-vhosts.conf,并开启</p><h3 id="创建虚拟主机"><a href="#创建虚拟主机" class="headerlink" title="创建虚拟主机"></a>创建虚拟主机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerName www.test.com #域名</span><br><span class="line">    DocumentRoot &quot;d:code/php/test&quot; #路径</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><h3 id="重启-apache"><a href="#重启-apache" class="headerlink" title="重启 apache"></a>重启 apache</h3><h3 id="修改-hosts-文件"><a href="#修改-hosts-文件" class="headerlink" title="修改 hosts 文件"></a>修改 hosts 文件</h3><p>hosts文件路径：C:\Windows\System32\drivers\etc\hosts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">127.0.0.1 test.com</span><br></pre></td></tr></table></figure><h3 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;d:code/php/test&quot;&gt; # 目录访问权限</span><br><span class="line">    Order Deny,Allow #设置顺序</span><br><span class="line">    Deny from all</span><br><span class="line">    Allow from all </span><br><span class="line">    DirectoryIndex indexs #指定访问方式，如果没有请求文件，而默认的文件又不存在，则显示所有的文件列表（在开发环境中应该禁用）</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>注意：一旦开启虚拟主机，那么默认的localhost会被覆盖，被第一个虚拟主机覆盖，为了解决不被覆盖的问题，需要额外增加一个localhost的虚拟主机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerName localhost</span><br><span class="line">    DocumentRoot &quot;d:server/apache/htdocs&quot; #网站根目录</span><br><span class="line">    </span><br><span class="line">    &lt;Directory &quot;d:code/php/test&quot;&gt; # 目录访问权限</span><br><span class="line">        Order Deny,Allow #设置顺序</span><br><span class="line">        Deny from all</span><br><span class="line">        Allow from all</span><br><span class="line">    </span><br><span class="line">        DirectoryIndex indexs #指定访问方式，如果没有请求文件，而默认的文件又不存在，则显示所有的文件列表（在开发环境中应该禁用）</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><h3 id="更加清晰的配置方法"><a href="#更加清晰的配置方法" class="headerlink" title="更加清晰的配置方法"></a>更加清晰的配置方法</h3><p>上面的配置方法是通用的配置虚拟主机的方式，但是随着越来越多的开发应用，会发现 Include conf/extra/http-vhosts.conf 里面会有越来越多的配置写在一起,有些早已不用的和正在使用的配置都加载在一起，不利于管理和修改。因此还可以采取以下的方式配置。</p><p>重新回到第1步中，打开 http.conf 文件，这次不要打开 Include conf/extra/http-vhosts.conf 的配置。而是在 http.conf 的最后一行添加 Include conf/extra/test.com.conf。</p><p>在 conf/extra 下面创建一个 test.com.conf 文件，然后将配置信息写入到文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NameVirtualHost *:80</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin phachon@163.com</span><br><span class="line">    DocumentRoot &quot;D:/server/apache/htdocs/test&quot;</span><br><span class="line">    DirectoryIndex index.php</span><br><span class="line">    ServerName test.com</span><br><span class="line">    &lt;Directory &quot;D:/server/apache/htdocs/test&quot;&gt;</span><br><span class="line">        Options Indexes FollowSymLinks</span><br><span class="line">        AllowOverride None</span><br><span class="line">        Order allow,deny</span><br><span class="line">        Allow from all</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>以后每新增一个虚拟主机配置就在 http.conf 的最后一行加载一下，并在 conf/extra 下创建对应的 conf 文件。</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Mysql </tag>
            
            <tag> Windows </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web 网站的基本工作原理</title>
      <link href="/2016/07/26/web-work/"/>
      <url>/2016/07/26/web-work/</url>
      <content type="html"><![CDATA[<hr><h2 id="静态页访问"><a href="#静态页访问" class="headerlink" title="静态页访问"></a>静态页访问</h2><ul><li>示例：<a href="http://www.test.com/index.html" target="_blank" rel="noopener">http://www.test.com/index.html</a></li><li>请求步骤：</li></ul><p>(1) 用户输入需要访问的地址或者具体的网页文件<br>(2) 开始域名解析,会先找到本地的 hosts 文件，然后再找网络上的 DNS 服务器,最终解析到 ip 地址<br>(3) ip 地址所在机器的 Web 服务器接收这个请求，获取请求文件 index.html<br>(4) web 服务器将这个文件的信息返回给用户所用的浏览器<br>(5) 浏览器解析 html 代码，显示出数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Title: 静态网页资源的访问流程图</span><br><span class="line">用户-&gt;浏览器:输入资源地址</span><br><span class="line">浏览器-&gt;域名解析(DNS):解析 ip</span><br><span class="line">域名解析(DNS)-&gt;web 服务器:根据 ip 找到服务器资源</span><br><span class="line">web 服务器-&gt;浏览器:返回资源给浏览器</span><br><span class="line">浏览器-&gt;用户:解析html显示</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="动态页访问"><a href="#动态页访问" class="headerlink" title="动态页访问"></a>动态页访问</h2><p>示例：<a href="http://www.test.com/test.php" target="_blank" rel="noopener">http://www.test.com/test.php</a></p><p>请求步骤：</p><p>(1) 用户浏览器输入网址以及请求的动态文件的脚本<br>(2) 域名解析，先找本地 hosts ,再找 DNS<br>(3) web 服务器接收请求,获取请求文件 test.php<br>(4) web 服务器将 test.php 交给 php 引擎处理<br>(5) php 引擎解析 php 代码,如果连接了数据库，就调用 mysql 扩展，去操作数据库，最终将解析成 html 文件<br>(6) 将解析的 html 文件返回给 web 服务器(Apache)<br>(7) web服务器返回 test.php 得到的最终 html 文件给浏览器<br>(8) 浏览器解析html代码，显示数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title:动态网页的访问流程图</span><br><span class="line">用户-&gt;浏览器:输入动态脚本地址</span><br><span class="line">浏览器-&gt;域名解析(DNS):解析域名</span><br><span class="line">域名解析(DNS)-&gt;Web服务器(Apache):ip定位到机器</span><br><span class="line">Web服务器(Apache)-&gt;php引擎:发送test.php</span><br><span class="line">php引擎-&gt;Web服务器(Apache):将解析成html文件返回</span><br><span class="line">Web服务器(Apache)-&gt;浏览器:将html返回</span><br><span class="line">浏览器-&gt;用户:解析html显示</span><br></pre></td></tr></table></figure><h2 id="apache-的工作原理"><a href="#apache-的工作原理" class="headerlink" title="apache 的工作原理"></a>apache 的工作原理</h2><p>Apache的诸多功能都是通过模块进行加载的，自己本身并不具备那么多能力（功能）,下图以 php 为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title:Apache 的工作示意图</span><br><span class="line">浏览器-&gt;Apache:http://test.com/test.php</span><br><span class="line">Apache-&gt;php引擎:test.php</span><br><span class="line">php引擎-&gt;php扩展:mysql扩展</span><br><span class="line">php扩展-&gt;mysql数据库:连接mysql</span><br><span class="line">mysql数据库-&gt;php引擎:返回数据给php引擎</span><br><span class="line">php引擎-&gt;Apache:解析成html返回</span><br><span class="line">Apache-&gt;浏览器:返回html给浏览器</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS 下安装 Memcache 和 php 扩展</title>
      <link href="/2016/07/26/centos-install-memcache/"/>
      <url>/2016/07/26/centos-install-memcache/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>CentOS 下安装 Memcache 和 php memcache 扩展</p></blockquote><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>查看相关软件包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yum search memcached</span><br></pre></td></tr></table></figure><p>有了，可以进行安装了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yum -y install memcached</span><br></pre></td></tr></table></figure><a id="more"></a><p>Memcache关联php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install php-pecl-memcache</span><br></pre></td></tr></table></figure><p>验证安装结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memcached -h</span><br><span class="line">php -m | grep memcache</span><br></pre></td></tr></table></figure><p>Memcache的基本设置<br>启动memcache的服务端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcached -d -m 100 -u root -l 222.186.xx.xxx -p 11211 -c 512 -P /tmp/memcached.pid</span><br></pre></td></tr></table></figure><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>-d    选项是启动一个守护进程；<br>-m    是分配给Memcache使用的内存数量，单位是MB，我这里是100MB；<br>-u    是运行Memcache的用户，我这里是root；<br>-l    是监听的服务器IP地址我这里指定了服务器的IP地址222.186.xx.xxx；<br>-p    是设置Memcache监听的端口，我这里设置了11211，最好是1024以上的端口；<br>-c    选项是最大运行的并发连接数，默认是1024，我这里设置了512，按照你服务器的负载量来设定；<br>-P    是设置保存Memcache的pid文件，我这里是保存在 /tmp/memcached.pid；</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>检查memcached是否启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Netstat -an | more</span><br><span class="line">tcp  0  0 222.186.xx.xxx:11211       0.0.0.0:*                   LIST</span><br></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chkconfig memcached on</span><br></pre></td></tr></table></figure><p>启动和停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Service memcached start | stop</span><br><span class="line">Or /etc/init.d/memcached start | stop</span><br></pre></td></tr></table></figure><p>重启centos </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shutdown -r now</span><br><span class="line">Or reboot</span><br></pre></td></tr></table></figure><p>编写 php 文件来验证 memcache 是否可用吧。</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> CentOS </tag>
            
            <tag> Memcache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS下php安装 mcrypt 扩展</title>
      <link href="/2016/07/25/centos-install-php-mcrypt/"/>
      <url>/2016/07/25/centos-install-php-mcrypt/</url>
      <content type="html"><![CDATA[<hr><h2 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h2><p>需要下载Libmcrypt,mhash,mcrypt安装包</p><p>下载地址：<a href="http://www.sourceforge.net" target="_blank" rel="noopener">http://www.sourceforge.net</a></p><ul><li>libmcrypt(libmcrypt-2.5.8.tar.gz );</li><li>mcrypt(mcrypt-2.6.8.tar.gz );</li><li>mhash(mhash-0.9.9.9.tar.gz );</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget &quot;http://downloads.sourceforge.net/mcrypt/libmcrypt-2.5.8.tar.gz&quot;</span><br><span class="line">wget &quot;http://downloads.sourceforge.net/mcrypt/mcrypt-2.6.8.tar.gz&quot;</span><br><span class="line">wget &quot;http://downloads.sourceforge.net/mhash/mhash-0.9.9.9.tar.gz&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="安装Lmcrypt"><a href="#安装Lmcrypt" class="headerlink" title="安装Lmcrypt"></a>安装Lmcrypt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf libmcrypt-2.5.8.tar.gz</span><br><span class="line">cd libmcrypt-2.5.8</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install #说明：libmcript默认安装在/usr/local</span><br></pre></td></tr></table></figure><h2 id="安装mhash"><a href="#安装mhash" class="headerlink" title="安装mhash"></a>安装mhash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf mhash-0.9.9.9.tar.gz</span><br><span class="line">cd mhash-0.9.9.9</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="安装mcrypt"><a href="#安装mcrypt" class="headerlink" title="安装mcrypt"></a>安装mcrypt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf mcrypt-2.6.8.tar.gz</span><br><span class="line">cd mcrypt-2.6.8</span><br><span class="line">LD_LIBRARY_PATH=/usr/local/lib ./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>安装php的mcrypt扩展(动态加载编译)</p><p>下载php下的mcrypt扩展或者直接下载php的完整安装包<br><a href="http://www.php.net/releases/" target="_blank" rel="noopener">http://www.php.net/releases/</a> 网页下找到自己服务器的php版本，下载后tar解压（本人的是php5.3.3）</p><p>进入ext/mcrypt文件夹<br>上传 mcrypt文件夹到你服务器的某个目录下然后进入此目录</p><p>执行phpize命令（phpize是用来扩展php扩展模块的，通过phpize可以建立php的外挂模块，如果没有？yum install php53-devel里包含了，或者其他方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@phachon 14:48 mcrypt] whereis phpize #phpize是否存在</span><br><span class="line">phpize: /usr/bin/phpize /usr/share/man/man1/phpize.1.gz</span><br><span class="line">[root@phachon 14:48 mcrypt] phpize</span><br><span class="line">Configuring for:</span><br><span class="line">PHP Api Version:         20090626</span><br><span class="line">Zend Module Api No:      20090626</span><br><span class="line">Zend Extension Api No:   220090626</span><br></pre></td></tr></table></figure><p>执行完后，会发现当前目录下多了一些configure文件，最后执行php-config命令就基本完成了<br>执行以下命令，确保你的/usr/bin/php-config是存在的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@phachon 15:02 mcrypt] whereis php-config</span><br><span class="line">php-config: /usr/bin/php-config /usr/share/man/man1/php-config.1.gz</span><br><span class="line">[root@phachon 15:02 mcrypt] ./configure --with-php-config=/usr/bin/php-config</span><br></pre></td></tr></table></figure><p>如果遇到以下错误，请先安装gcc，命令yum install gcc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: no acceptable C compiler found in $PATH</span><br></pre></td></tr></table></figure><p>直到不报错，出现：config.status: creating config.h，执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@phachon 15:06 mcrypt] make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>提示如下，说明你安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Installing shared extensions:     /usr/lib64/php/modules/</span><br></pre></td></tr></table></figure><p>顺便检查下/usr/lib64/php/modules/里的mrcypt.so扩展是否已经创建成功</p><p>然后的事就简单了，给你的php.ini添加一条extension=mcrypt.so</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@phachon 15:09 mcrypt] cd /etc/php.d</span><br></pre></td></tr></table></figure><p>创建一个mrcypt.ini文件就行，里面写extension=mcrypt.so</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@phachon 15:17 php.d] echo &apos;extension=mcrypt.so&apos; &gt; mcrypt.ini</span><br></pre></td></tr></table></figure><p>重启apache，phpinfo()，查看 mcrypt 模块扩展是不是加载了</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> CentOS </tag>
            
            <tag> mcrypt </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lump yum 安装与搭建</title>
      <link href="/2016/07/25/lamp-yum-install/"/>
      <url>/2016/07/25/lamp-yum-install/</url>
      <content type="html"><![CDATA[<hr><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="配置防火墙，开启-80，3306-端口"><a href="#配置防火墙，开启-80，3306-端口" class="headerlink" title="配置防火墙，开启 80，3306 端口"></a>配置防火墙，开启 80，3306 端口</h3><p>打开iptables</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><p>允许80端口通过防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许3306端口通过防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许21端口通过防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>备注：把这两条规则添加到防火墙配置的最后一行，导致防火墙启动失败，<br>正确的应该是添加到默认的22端口这条规则的下面</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#Firewall configuration written by system-config-firewall</span><br><span class="line">#Manual customization of this file is not recommended.</span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/iptables restart #最后重启防火墙使配置生效</span><br></pre></td></tr></table></figure><h3 id="关闭SELINUX"><a href="#关闭SELINUX" class="headerlink" title="关闭SELINUX"></a>关闭SELINUX</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br><span class="line"></span><br><span class="line">SELINUX=enforcing #注释掉</span><br><span class="line">SELINUXTYPE=targeted #注释掉</span><br><span class="line">SELINUX=disabled #增加</span><br><span class="line"></span><br><span class="line">:wq #保存，关闭</span><br><span class="line">shutdown -r now #重启系统</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd #根据提示，输入 y 安装即可</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/httpd start #启动 Apache</span><br></pre></td></tr></table></figure><p>备注：Apache 启动后可能会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正在启动 httpd:httpd: Could not reliably determine the server&apos;s fully qualif domain name, using ::1 for ServerName</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure><p>找到 #ServerName <a href="http://www.example.com:80" target="_blank" rel="noopener">www.example.com:80</a><br>修改为 ServerName <a href="http://www.osyunwei.com:80" target="_blank" rel="noopener">www.osyunwei.com:80</a> #这里设置为你自己的域名，如果没有域名，可以设置为localhost</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:wq! #保存退出</span><br><span class="line">chkconfig httpd on #设为开机启动</span><br><span class="line">/etc/init.d/httpd restart #重启Apache</span><br></pre></td></tr></table></figure><h3 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql mysql-server #询问是否安装，输入Y自动安装</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/mysqld start #启动MySQL</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig mysqld on #设为开机启动</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/mysql/my-medium.cnf /etc/my.cnf #拷贝配置文件（注意：如果/etc目录下面默认有一个my.cnf，直接覆盖即可）</span><br></pre></td></tr></table></figure><h4 id="为-root-账户设置密码"><a href="#为-root-账户设置密码" class="headerlink" title="为 root  账户设置密码"></a>为 root  账户设置密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p>回车，根据提示输入Y<br>输入2次密码，回车<br>根据提示一路输入Y<br>最后出现：Thanks for using MySQL!<br>MySql密码设置完成，重新启动 MySQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/mysqld restart #重启</span><br><span class="line">/etc/init.d/mysqld stop #停止</span><br><span class="line">/etc/init.d/mysqld start #启动</span><br></pre></td></tr></table></figure><h3 id="安装PHP5"><a href="#安装PHP5" class="headerlink" title="安装PHP5"></a>安装PHP5</h3><p>(1) 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install php #根据提示输入Y直到安装完成</span><br></pre></td></tr></table></figure><p>(2) 安装 php 组件，使 PHP5 支持Mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install php-mysql php-gd libjpeg* php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt php-bcmath php-mhash libmcrypt</span><br></pre></td></tr></table></figure><p>这里选择以上安装包进行安装<br>根据提示输入Y回车</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/mysqld restart #重启MySql</span><br><span class="line">/etc/init.d/httpd restart #重启Apche</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Apache-配置"><a href="#Apache-配置" class="headerlink" title="Apache 配置"></a>Apache 配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/httpd/conf/httpd.conf #编辑 apache 配置文件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerTokens OS　    #在44行 修改为：ServerTokens Prod （在出现错误页的时候不显示服务器操作系统的名称）</span><br><span class="line">ServerSignature On　 #在536行 修改为：ServerSignature Off （在错误页中不显示Apache的版本）</span><br><span class="line">Options Indexes FollowSymLinks　 #在331行 修改为：Options Includes ExecCGI FollowSymLinks   #允许服务器执行CGI及SSI，禁止列出目录</span><br><span class="line">AddHandler cgi-script .cgi　#在796行 修改为：AddHandler cgi-script .cgi .pl （允许扩展名为.pl的CGI脚本运行）</span><br><span class="line">AllowOverride None　 #在338行 修改为：AllowOverride All （允许.htaccess）</span><br><span class="line">AddDefaultCharset UTF-8　#在759行 修改为：AddDefaultCharset GB2312　（添加GB2312为默认编码）</span><br><span class="line">Options Indexes MultiViews FollowSymLinks  #在554行 修改为</span><br><span class="line">Options MultiViews FollowSymLinks  #不在浏览器上显示树状目录结构</span><br><span class="line">DirectoryIndex index.html index.html.var #在402行 修改为</span><br><span class="line">DirectoryIndex index.html index.htm Default.html Default.htm</span><br><span class="line">index.php Default.php index.html.var （设置默认首页文件，增加index.php）</span><br><span class="line">KeepAlive Off #在76行 修改为：KeepAlive On （允许程序性联机）</span><br><span class="line">MaxKeepAliveRequests 100 #在83行 修改为 MaxKeepAliveRequests 1000 （增加同时连接数）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:wq! #保存退出</span><br><span class="line">/etc/init.d/httpd restart #重启</span><br><span class="line">rm -f /etc/httpd/conf.d/welcome.conf /var/www/error/noindex.html #删除默认测试页</span><br></pre></td></tr></table></figure><h3 id="php-配置"><a href="#php-配置" class="headerlink" title="php 配置"></a>php 配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/php.ini #编辑</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date.timezone = PRC #在946行 把前面的分号去掉，改为date.timezone = PRC</span><br><span class="line">disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,escapeshellcmd,dll,popen,disk_free_space,checkdnsrr,checkdnsrr,getservbyname,getservbyport,disk_total_space,posix_ctermid,posix_get_last_error,posix_getcwd, posix_getegid,posix_geteuid,posix_getgid, posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid, posix_getppid,posix_getpwnam,posix_getpwuid, posix_getrlimit, posix_getsid,posix_getuid,posix_isatty, posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid, posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname</span><br></pre></td></tr></table></figure><p>在386行 列出PHP可以禁用的函数，如果某些程序需要用到这个函数，可以删除，取消禁用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expose_php = Off #在432行 禁止显示php版本的信息</span><br><span class="line">magic_quotes_gpc = On #在745行 打开magic_quotes_gpc来防止SQL注入</span><br><span class="line">short_open_tag = ON #在229行支持php短标签</span><br><span class="line">open_basedir = .:/tmp/ #在380行 设置表示允许访问当前目录(即PHP脚本文件所在之目录)和/tmp/目录,可以防止php木马跨站,如果改了之后安装程序有问题，可以注销此行，或者直接写上程序的目录/data/www.osyunwei.com/:/tmp/</span><br><span class="line">:wq! #保存退出</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/mysqld restart #重启MySql</span><br><span class="line">/etc/init.d/httpd restart  #重启Apche</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Mysql </tag>
            
            <tag> CentOS 6.4 </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux网络配置</title>
      <link href="/2016/07/24/linux-network-config/"/>
      <url>/2016/07/24/linux-network-config/</url>
      <content type="html"><![CDATA[<hr><h2 id="配置网络信息"><a href="#配置网络信息" class="headerlink" title="配置网络信息"></a>配置网络信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure><p>打开ifcfg-eth0这个文件</p><p><img src="http://img.blog.csdn.net/20160724180749720" alt="这里写图片描述"></p><p>在这个文件中，保存了第一块网卡的配置信息</p><ul><li>DEVICE    ：设备名</li><li>ONBOOT    ：当系统启动后是否自动启动网卡设备   </li><li>BOOTPROTO    ：获取IP方式   static：静态获取</li><li>IPADDR    ：ip地址</li><li>NETMASK    ：子网掩码</li><li>GATEWAY    ：网关</li></ul><a id="more"></a><p>如果没有IPADDR    ：ip地址<br>则添加IPADDR=自己设置的ip地址<br>修改ONBOOT=”yes” BOOTPROTO=”static”<br>修改完后：  :wq 或者  :x 保存退出</p><p><img src="http://img.blog.csdn.net/20160724180846978" alt="这里写图片描述"></p><h2 id="启动网络设备"><a href="#启动网络设备" class="headerlink" title="启动网络设备"></a>启动网络设备</h2><p>(1) service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service  network  start|restart|stop</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160724181211607" alt="这里写图片描述"></p><p>(2) ifup、ifdown</p><p>ifup：启用<br>ifdown：关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifup eth0  ifdown eth0</span><br></pre></td></tr></table></figure><h2 id="测试网络连接"><a href="#测试网络连接" class="headerlink" title="测试网络连接"></a>测试网络连接</h2><p>(1) ifconfig 查看当前网络设备</p><p><img src="http://img.blog.csdn.net/20160724181414000" alt="这里写图片描述"></p><p>(2) ping</p><p><img src="http://img.blog.csdn.net/20160724181556474" alt="这里写图片描述"></p><p>说明网络连接成功。</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
